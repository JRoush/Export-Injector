/** \file
 *  This C source file was generated by $ANTLR version 3.2 Sep 23, 2009 12:02:23
 *
 *     -  From the grammar source file : F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g
 *     -                            On : 2010-11-13 20:24:13
 *     -                for the parser : EEDGrammarParserParser *
 * Editing it, at least manually, is not wise. 
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD licence"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "EEDGrammarParser.h"

	// instantiations of global vars
	std::vector<unsigned long>	g_LoadingBases;
	std::vector<ExportManager*> g_ExportManagers;

/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */
 
#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pEEDGrammarParser_##scope##_SCOPE
#define SCOPE_STACK(scope)  pEEDGrammarParser_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pEEDGrammarParser_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pEEDGrammarParser_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */
 
#undef	    PARSER		    
#undef	    RECOGNIZER		    
#undef	    HAVEPARSEDRULE
#undef		MEMOIZE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef		INDEX
#undef      ADAPTOR
#undef		SEEK
#undef	    RULEMEMO		    
#undef		DBG

#define	    PARSER							ctx->pParser  
#define	    RECOGNIZER						PARSER->rec
#define		PSRSTATE						RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)				RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define		MEMOIZE(ri,si)					RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define	    INPUT							PARSER->tstream
#define	    STRSTREAM						INPUT
#define		ISTREAM							INPUT->istream
#define		INDEX()							ISTREAM->index(INPUT->istream)
#define	    HASEXCEPTION()					(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION						PSRSTATE->exception
#define	    MATCHT(t, fs)					RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()						RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK					    PSRSTATE->following
#define	    FOLLOWPUSH(x)					FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()						FOLLOWSTACK->pop(FOLLOWSTACK)
#define	    PRECOVER()						RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()					RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)							INPUT->istream->_LA(ISTREAM, n)
#define	    LT(n)							INPUT->_LT(INPUT, n)
#define	    CONSTRUCTEX()					RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()						ISTREAM->consume(ISTREAM)
#define	    MARK()							ISTREAM->mark(ISTREAM)
#define	    REWIND(m)						ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()					ISTREAM->rewindLast(ISTREAM)
#define		SEEK(n)							ISTREAM->seek(ISTREAM, n)
#define	    PERRORRECOVERY					PSRSTATE->errorRecovery
#define	    FAILEDFLAG						PSRSTATE->failed
#define	    HASFAILED()						(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING					PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         ctx->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		DBG								RECOGNIZER->debugger

#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */



/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   EEDGrammarParserTokenNames[77+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>", 
        (pANTLR3_UINT8) "<UP>", 
        (pANTLR3_UINT8) "APPLOADER",
        (pANTLR3_UINT8) "CODE",
        (pANTLR3_UINT8) "CONFORMING",
        (pANTLR3_UINT8) "DESCRIPTION",
        (pANTLR3_UINT8) "DEV386",
        (pANTLR3_UINT8) "DISCARDABLE",
        (pANTLR3_UINT8) "DYNAMIC",
        (pANTLR3_UINT8) "EXECUTE_ONLY",
        (pANTLR3_UINT8) "EXECUTEONLY",
        (pANTLR3_UINT8) "EXECUTEREAD",
        (pANTLR3_UINT8) "EXETYPE",
        (pANTLR3_UINT8) "FIXED",
        (pANTLR3_UINT8) "FUNCTIONS",
        (pANTLR3_UINT8) "IMPORTS",
        (pANTLR3_UINT8) "IMPURE",
        (pANTLR3_UINT8) "INCLUDE",
        (pANTLR3_UINT8) "INITINSTANCE",
        (pANTLR3_UINT8) "IOPL",
        (pANTLR3_UINT8) "LOADONCALL",
        (pANTLR3_UINT8) "LONGNAMES",
        (pANTLR3_UINT8) "MOVABLE",
        (pANTLR3_UINT8) "MOVEABLE",
        (pANTLR3_UINT8) "MULTIPLE",
        (pANTLR3_UINT8) "NEWFILES",
        (pANTLR3_UINT8) "NODATA",
        (pANTLR3_UINT8) "NOIOPL",
        (pANTLR3_UINT8) "NONCONFORMING",
        (pANTLR3_UINT8) "NONDISCARDABLE",
        (pANTLR3_UINT8) "NONE",
        (pANTLR3_UINT8) "NONSHARED",
        (pANTLR3_UINT8) "NOTWINDOWCOMPAT",
        (pANTLR3_UINT8) "OBJECTS",
        (pANTLR3_UINT8) "OLD",
        (pANTLR3_UINT8) "PRELOAD",
        (pANTLR3_UINT8) "PROTMODE",
        (pANTLR3_UINT8) "PURE",
        (pANTLR3_UINT8) "READONLY",
        (pANTLR3_UINT8) "READWRITE",
        (pANTLR3_UINT8) "REALMODE",
        (pANTLR3_UINT8) "RESIDENT",
        (pANTLR3_UINT8) "RESIDENTNAME",
        (pANTLR3_UINT8) "SINGLE",
        (pANTLR3_UINT8) "WINDOWAPI",
        (pANTLR3_UINT8) "WINDOWCOMPAT",
        (pANTLR3_UINT8) "WINDOWS",
        (pANTLR3_UINT8) "INT",
        (pANTLR3_UINT8) "SYMBOL",
        (pANTLR3_UINT8) "HEX",
        (pANTLR3_UINT8) "STRING",
        (pANTLR3_UINT8) "COMMENT",
        (pANTLR3_UINT8) "WSTOKEN",
        (pANTLR3_UINT8) "WHITESPACE",
        (pANTLR3_UINT8) "'NAME'",
        (pANTLR3_UINT8) "'LIBRARY'",
        (pANTLR3_UINT8) "','",
        (pANTLR3_UINT8) "'BASE'",
        (pANTLR3_UINT8) "'='",
        (pANTLR3_UINT8) "'VERSION'",
        (pANTLR3_UINT8) "'.'",
        (pANTLR3_UINT8) "'EXPORTS'",
        (pANTLR3_UINT8) "'@'",
        (pANTLR3_UINT8) "'NONAME'",
        (pANTLR3_UINT8) "'PRIVATE'",
        (pANTLR3_UINT8) "'DATA'",
        (pANTLR3_UINT8) "'#'",
        (pANTLR3_UINT8) "':'",
        (pANTLR3_UINT8) "'HEAPSIZE'",
        (pANTLR3_UINT8) "'STACKSIZE'",
        (pANTLR3_UINT8) "'STUB'",
        (pANTLR3_UINT8) "'SECTIONS'",
        (pANTLR3_UINT8) "'SEGMENTS'",
        (pANTLR3_UINT8) "'READ'",
        (pANTLR3_UINT8) "'WRITE'",
        (pANTLR3_UINT8) "'EXECUTE'",
        (pANTLR3_UINT8) "'SHARED'",
        (pANTLR3_UINT8) "'\\\\'",
        (pANTLR3_UINT8) "'/'"
       };

        

// Forward declare the locally static matching functions we have generated.
//
static void	file    (pEEDGrammarParser ctx);
static void	statement    (pEEDGrammarParser ctx);
static void	nameStatement    (pEEDGrammarParser ctx);
static void	baseStatement    (pEEDGrammarParser ctx);
static void	versionStatement    (pEEDGrammarParser ctx);
static void	versionDesc    (pEEDGrammarParser ctx);
static void	exportStatement    (pEEDGrammarParser ctx);
static void	exportSymbol    (pEEDGrammarParser ctx);
static unsigned long	symbolSource    (pEEDGrammarParser ctx, unsigned long idxModule);
static void	heapsizeStatement    (pEEDGrammarParser ctx);
static void	stacksizeStatement    (pEEDGrammarParser ctx);
static void	stubStatement    (pEEDGrammarParser ctx);
static void	sectionsStatement    (pEEDGrammarParser ctx);
static long	number    (pEEDGrammarParser ctx);
static EEDGrammarParser_filename_return	filename    (pEEDGrammarParser ctx);
static void	EEDGrammarParserFree(pEEDGrammarParser ctx);
/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed. 
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new EEDGrammarParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pEEDGrammarParser
EEDGrammarParserNew   (pANTLR3_COMMON_TOKEN_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return EEDGrammarParserNewSSD(instream, NULL);
}

/** \brief Create a new EEDGrammarParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pEEDGrammarParser
EEDGrammarParserNewSSD   (pANTLR3_COMMON_TOKEN_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pEEDGrammarParser ctx;	    /* Context structure we will build and return   */
    
    ctx	= (pEEDGrammarParser) ANTLR3_CALLOC(1, sizeof(EEDGrammarParser));
    
    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }
    
    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function. 
     *
     * We don't use the macros defined in EEDGrammarParser.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base parser/recognizer, using the supplied token stream
     */
    ctx->pParser	    = antlr3ParserNewStream(ANTLR3_SIZE_HINT, instream->tstream, state);
    /* Install the implementation of our EEDGrammarParser interface
     */
    ctx->file	= file;
    ctx->statement	= statement;
    ctx->nameStatement	= nameStatement;
    ctx->baseStatement	= baseStatement;
    ctx->versionStatement	= versionStatement;
    ctx->versionDesc	= versionDesc;
    ctx->exportStatement	= exportStatement;
    ctx->exportSymbol	= exportSymbol;
    ctx->symbolSource	= symbolSource;
    ctx->heapsizeStatement	= heapsizeStatement;
    ctx->stacksizeStatement	= stacksizeStatement;
    ctx->stubStatement	= stubStatement;
    ctx->sectionsStatement	= sectionsStatement;
    ctx->number	= number;
    ctx->filename	= filename;
    ctx->free			= EEDGrammarParserFree;
    ctx->getGrammarFileName	= getGrammarFileName;
    
    /* Install the scope pushing methods.
     */

        
    

	
    /* Install the token table
     */
    PSRSTATE->tokenNames   = EEDGrammarParserTokenNames;
    
    
    /* Return the newly built parser to the caller
     */
    return  ctx;
}

/** Free the parser resources
 */
 static void
 EEDGrammarParserFree(pEEDGrammarParser ctx)
 {
    /* Free any scope memory
     */
    
        
	// Free this parser
	//
    ctx->pParser->free(ctx->pParser);
    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }
 
/** Return token names used by this parser
 *
 * The returned pointer is used as an index into the token names table (using the token 
 * number as the index).
 * 
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames() 
{
        return EEDGrammarParserTokenNames; 
}

    
/* Declare the bitsets
 */

/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_file510  */
static	ANTLR3_BITWORD FOLLOW_statement_in_file510_bits[]	= { ANTLR3_UINT64_LIT(0xAB00000000000002), ANTLR3_UINT64_LIT(0x00000000000007C0) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_file510	= { FOLLOW_statement_in_file510_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_nameStatement_in_statement522  */
static	ANTLR3_BITWORD FOLLOW_nameStatement_in_statement522_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_nameStatement_in_statement522	= { FOLLOW_nameStatement_in_statement522_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_baseStatement_in_statement527  */
static	ANTLR3_BITWORD FOLLOW_baseStatement_in_statement527_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_baseStatement_in_statement527	= { FOLLOW_baseStatement_in_statement527_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_exportStatement_in_statement532  */
static	ANTLR3_BITWORD FOLLOW_exportStatement_in_statement532_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_exportStatement_in_statement532	= { FOLLOW_exportStatement_in_statement532_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_versionStatement_in_statement537  */
static	ANTLR3_BITWORD FOLLOW_versionStatement_in_statement537_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_versionStatement_in_statement537	= { FOLLOW_versionStatement_in_statement537_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_heapsizeStatement_in_statement542  */
static	ANTLR3_BITWORD FOLLOW_heapsizeStatement_in_statement542_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_heapsizeStatement_in_statement542	= { FOLLOW_heapsizeStatement_in_statement542_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_stacksizeStatement_in_statement547  */
static	ANTLR3_BITWORD FOLLOW_stacksizeStatement_in_statement547_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_stacksizeStatement_in_statement547	= { FOLLOW_stacksizeStatement_in_statement547_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_stubStatement_in_statement552  */
static	ANTLR3_BITWORD FOLLOW_stubStatement_in_statement552_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_stubStatement_in_statement552	= { FOLLOW_stubStatement_in_statement552_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sectionsStatement_in_statement557  */
static	ANTLR3_BITWORD FOLLOW_sectionsStatement_in_statement557_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sectionsStatement_in_statement557	= { FOLLOW_sectionsStatement_in_statement557_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_nameStatement574  */
static	ANTLR3_BITWORD FOLLOW_set_in_nameStatement574_bits[]	= { ANTLR3_UINT64_LIT(0x401E000000000000), ANTLR3_UINT64_LIT(0x0000000000018020) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_nameStatement574	= { FOLLOW_set_in_nameStatement574_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_filename_in_nameStatement582  */
static	ANTLR3_BITWORD FOLLOW_filename_in_nameStatement582_bits[]	= { ANTLR3_UINT64_LIT(0x0400000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_filename_in_nameStatement582	= { FOLLOW_filename_in_nameStatement582_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_58_in_nameStatement589  */
static	ANTLR3_BITWORD FOLLOW_58_in_nameStatement589_bits[]	= { ANTLR3_UINT64_LIT(0x401E000000000000), ANTLR3_UINT64_LIT(0x0000000000018020) };
static  ANTLR3_BITSET_LIST FOLLOW_58_in_nameStatement589	= { FOLLOW_58_in_nameStatement589_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_filename_in_nameStatement593  */
static	ANTLR3_BITWORD FOLLOW_filename_in_nameStatement593_bits[]	= { ANTLR3_UINT64_LIT(0x0400000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_filename_in_nameStatement593	= { FOLLOW_filename_in_nameStatement593_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_59_in_baseStatement619  */
static	ANTLR3_BITWORD FOLLOW_59_in_baseStatement619_bits[]	= { ANTLR3_UINT64_LIT(0x1000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_59_in_baseStatement619	= { FOLLOW_59_in_baseStatement619_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_60_in_baseStatement621  */
static	ANTLR3_BITWORD FOLLOW_60_in_baseStatement621_bits[]	= { ANTLR3_UINT64_LIT(0x000A000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_60_in_baseStatement621	= { FOLLOW_60_in_baseStatement621_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_number_in_baseStatement625  */
static	ANTLR3_BITWORD FOLLOW_number_in_baseStatement625_bits[]	= { ANTLR3_UINT64_LIT(0x0400000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_number_in_baseStatement625	= { FOLLOW_number_in_baseStatement625_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_58_in_baseStatement633  */
static	ANTLR3_BITWORD FOLLOW_58_in_baseStatement633_bits[]	= { ANTLR3_UINT64_LIT(0x000A000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_58_in_baseStatement633	= { FOLLOW_58_in_baseStatement633_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_number_in_baseStatement637  */
static	ANTLR3_BITWORD FOLLOW_number_in_baseStatement637_bits[]	= { ANTLR3_UINT64_LIT(0x0400000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_number_in_baseStatement637	= { FOLLOW_number_in_baseStatement637_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_61_in_versionStatement659  */
static	ANTLR3_BITWORD FOLLOW_61_in_versionStatement659_bits[]	= { ANTLR3_UINT64_LIT(0x1000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_61_in_versionStatement659	= { FOLLOW_61_in_versionStatement659_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_60_in_versionStatement661  */
static	ANTLR3_BITWORD FOLLOW_60_in_versionStatement661_bits[]	= { ANTLR3_UINT64_LIT(0x0002000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_60_in_versionStatement661	= { FOLLOW_60_in_versionStatement661_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_versionDesc_in_versionStatement662  */
static	ANTLR3_BITWORD FOLLOW_versionDesc_in_versionStatement662_bits[]	= { ANTLR3_UINT64_LIT(0x0400000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_versionDesc_in_versionStatement662	= { FOLLOW_versionDesc_in_versionStatement662_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_58_in_versionStatement665  */
static	ANTLR3_BITWORD FOLLOW_58_in_versionStatement665_bits[]	= { ANTLR3_UINT64_LIT(0x0002000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_58_in_versionStatement665	= { FOLLOW_58_in_versionStatement665_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_versionDesc_in_versionStatement667  */
static	ANTLR3_BITWORD FOLLOW_versionDesc_in_versionStatement667_bits[]	= { ANTLR3_UINT64_LIT(0x0400000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_versionDesc_in_versionStatement667	= { FOLLOW_versionDesc_in_versionStatement667_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INT_in_versionDesc678  */
static	ANTLR3_BITWORD FOLLOW_INT_in_versionDesc678_bits[]	= { ANTLR3_UINT64_LIT(0x4000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_INT_in_versionDesc678	= { FOLLOW_INT_in_versionDesc678_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_62_in_versionDesc681  */
static	ANTLR3_BITWORD FOLLOW_62_in_versionDesc681_bits[]	= { ANTLR3_UINT64_LIT(0x0002000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_62_in_versionDesc681	= { FOLLOW_62_in_versionDesc681_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INT_in_versionDesc683  */
static	ANTLR3_BITWORD FOLLOW_INT_in_versionDesc683_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_INT_in_versionDesc683	= { FOLLOW_INT_in_versionDesc683_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_63_in_exportStatement696  */
static	ANTLR3_BITWORD FOLLOW_63_in_exportStatement696_bits[]	= { ANTLR3_UINT64_LIT(0x0004000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_63_in_exportStatement696	= { FOLLOW_63_in_exportStatement696_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_exportSymbol_in_exportStatement700  */
static	ANTLR3_BITWORD FOLLOW_exportSymbol_in_exportStatement700_bits[]	= { ANTLR3_UINT64_LIT(0x0004000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_exportSymbol_in_exportStatement700	= { FOLLOW_exportSymbol_in_exportStatement700_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SYMBOL_in_exportSymbol723  */
static	ANTLR3_BITWORD FOLLOW_SYMBOL_in_exportSymbol723_bits[]	= { ANTLR3_UINT64_LIT(0x1000000000000002), ANTLR3_UINT64_LIT(0x000000000000000D) };
static  ANTLR3_BITSET_LIST FOLLOW_SYMBOL_in_exportSymbol723	= { FOLLOW_SYMBOL_in_exportSymbol723_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_60_in_exportSymbol730  */
static	ANTLR3_BITWORD FOLLOW_60_in_exportSymbol730_bits[]	= { ANTLR3_UINT64_LIT(0x000E000000000000), ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_60_in_exportSymbol730	= { FOLLOW_60_in_exportSymbol730_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbolSource_in_exportSymbol734  */
static	ANTLR3_BITWORD FOLLOW_symbolSource_in_exportSymbol734_bits[]	= { ANTLR3_UINT64_LIT(0x0400000000000002), ANTLR3_UINT64_LIT(0x000000000000000D) };
static  ANTLR3_BITSET_LIST FOLLOW_symbolSource_in_exportSymbol734	= { FOLLOW_symbolSource_in_exportSymbol734_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_58_in_exportSymbol743  */
static	ANTLR3_BITWORD FOLLOW_58_in_exportSymbol743_bits[]	= { ANTLR3_UINT64_LIT(0x000E000000000000), ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_58_in_exportSymbol743	= { FOLLOW_58_in_exportSymbol743_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_symbolSource_in_exportSymbol747  */
static	ANTLR3_BITWORD FOLLOW_symbolSource_in_exportSymbol747_bits[]	= { ANTLR3_UINT64_LIT(0x0400000000000002), ANTLR3_UINT64_LIT(0x000000000000000D) };
static  ANTLR3_BITSET_LIST FOLLOW_symbolSource_in_exportSymbol747	= { FOLLOW_symbolSource_in_exportSymbol747_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_64_in_exportSymbol764  */
static	ANTLR3_BITWORD FOLLOW_64_in_exportSymbol764_bits[]	= { ANTLR3_UINT64_LIT(0x000A000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_64_in_exportSymbol764	= { FOLLOW_64_in_exportSymbol764_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_number_in_exportSymbol768  */
static	ANTLR3_BITWORD FOLLOW_number_in_exportSymbol768_bits[]	= { ANTLR3_UINT64_LIT(0x0400000000000002), ANTLR3_UINT64_LIT(0x000000000000000E) };
static  ANTLR3_BITSET_LIST FOLLOW_number_in_exportSymbol768	= { FOLLOW_number_in_exportSymbol768_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_58_in_exportSymbol776  */
static	ANTLR3_BITWORD FOLLOW_58_in_exportSymbol776_bits[]	= { ANTLR3_UINT64_LIT(0x000A000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_58_in_exportSymbol776	= { FOLLOW_58_in_exportSymbol776_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_number_in_exportSymbol780  */
static	ANTLR3_BITWORD FOLLOW_number_in_exportSymbol780_bits[]	= { ANTLR3_UINT64_LIT(0x0400000000000002), ANTLR3_UINT64_LIT(0x000000000000000E) };
static  ANTLR3_BITSET_LIST FOLLOW_number_in_exportSymbol780	= { FOLLOW_number_in_exportSymbol780_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_65_in_exportSymbol792  */
static	ANTLR3_BITWORD FOLLOW_65_in_exportSymbol792_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x000000000000000C) };
static  ANTLR3_BITSET_LIST FOLLOW_65_in_exportSymbol792	= { FOLLOW_65_in_exportSymbol792_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_66_in_exportSymbol806  */
static	ANTLR3_BITWORD FOLLOW_66_in_exportSymbol806_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_66_in_exportSymbol806	= { FOLLOW_66_in_exportSymbol806_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_67_in_exportSymbol809  */
static	ANTLR3_BITWORD FOLLOW_67_in_exportSymbol809_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_67_in_exportSymbol809	= { FOLLOW_67_in_exportSymbol809_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_68_in_symbolSource837  */
static	ANTLR3_BITWORD FOLLOW_68_in_symbolSource837_bits[]	= { ANTLR3_UINT64_LIT(0x000A000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_68_in_symbolSource837	= { FOLLOW_68_in_symbolSource837_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_number_in_symbolSource844  */
static	ANTLR3_BITWORD FOLLOW_number_in_symbolSource844_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_number_in_symbolSource844	= { FOLLOW_number_in_symbolSource844_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SYMBOL_in_symbolSource851  */
static	ANTLR3_BITWORD FOLLOW_SYMBOL_in_symbolSource851_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_SYMBOL_in_symbolSource851	= { FOLLOW_SYMBOL_in_symbolSource851_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_69_in_symbolSource854  */
static	ANTLR3_BITWORD FOLLOW_69_in_symbolSource854_bits[]	= { ANTLR3_UINT64_LIT(0x401E000000000000), ANTLR3_UINT64_LIT(0x0000000000018020) };
static  ANTLR3_BITSET_LIST FOLLOW_69_in_symbolSource854	= { FOLLOW_69_in_symbolSource854_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_filename_in_symbolSource856  */
static	ANTLR3_BITWORD FOLLOW_filename_in_symbolSource856_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_filename_in_symbolSource856	= { FOLLOW_filename_in_symbolSource856_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_70_in_heapsizeStatement878  */
static	ANTLR3_BITWORD FOLLOW_70_in_heapsizeStatement878_bits[]	= { ANTLR3_UINT64_LIT(0x1000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_70_in_heapsizeStatement878	= { FOLLOW_70_in_heapsizeStatement878_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_60_in_heapsizeStatement880  */
static	ANTLR3_BITWORD FOLLOW_60_in_heapsizeStatement880_bits[]	= { ANTLR3_UINT64_LIT(0x000A000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_60_in_heapsizeStatement880	= { FOLLOW_60_in_heapsizeStatement880_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_number_in_heapsizeStatement882  */
static	ANTLR3_BITWORD FOLLOW_number_in_heapsizeStatement882_bits[]	= { ANTLR3_UINT64_LIT(0x0400000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_number_in_heapsizeStatement882	= { FOLLOW_number_in_heapsizeStatement882_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_58_in_heapsizeStatement885  */
static	ANTLR3_BITWORD FOLLOW_58_in_heapsizeStatement885_bits[]	= { ANTLR3_UINT64_LIT(0x000A000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_58_in_heapsizeStatement885	= { FOLLOW_58_in_heapsizeStatement885_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_number_in_heapsizeStatement887  */
static	ANTLR3_BITWORD FOLLOW_number_in_heapsizeStatement887_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_number_in_heapsizeStatement887	= { FOLLOW_number_in_heapsizeStatement887_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_71_in_stacksizeStatement901  */
static	ANTLR3_BITWORD FOLLOW_71_in_stacksizeStatement901_bits[]	= { ANTLR3_UINT64_LIT(0x1000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_71_in_stacksizeStatement901	= { FOLLOW_71_in_stacksizeStatement901_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_60_in_stacksizeStatement903  */
static	ANTLR3_BITWORD FOLLOW_60_in_stacksizeStatement903_bits[]	= { ANTLR3_UINT64_LIT(0x000A000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_60_in_stacksizeStatement903	= { FOLLOW_60_in_stacksizeStatement903_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_number_in_stacksizeStatement905  */
static	ANTLR3_BITWORD FOLLOW_number_in_stacksizeStatement905_bits[]	= { ANTLR3_UINT64_LIT(0x0400000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_number_in_stacksizeStatement905	= { FOLLOW_number_in_stacksizeStatement905_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_58_in_stacksizeStatement908  */
static	ANTLR3_BITWORD FOLLOW_58_in_stacksizeStatement908_bits[]	= { ANTLR3_UINT64_LIT(0x000A000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_58_in_stacksizeStatement908	= { FOLLOW_58_in_stacksizeStatement908_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_number_in_stacksizeStatement910  */
static	ANTLR3_BITWORD FOLLOW_number_in_stacksizeStatement910_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_number_in_stacksizeStatement910	= { FOLLOW_number_in_stacksizeStatement910_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_72_in_stubStatement924  */
static	ANTLR3_BITWORD FOLLOW_72_in_stubStatement924_bits[]	= { ANTLR3_UINT64_LIT(0x401E000000000000), ANTLR3_UINT64_LIT(0x0000000000018020) };
static  ANTLR3_BITSET_LIST FOLLOW_72_in_stubStatement924	= { FOLLOW_72_in_stubStatement924_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_filename_in_stubStatement926  */
static	ANTLR3_BITWORD FOLLOW_filename_in_stubStatement926_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_filename_in_stubStatement926	= { FOLLOW_filename_in_stubStatement926_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_sectionsStatement939  */
static	ANTLR3_BITWORD FOLLOW_set_in_sectionsStatement939_bits[]	= { ANTLR3_UINT64_LIT(0x4000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_sectionsStatement939	= { FOLLOW_set_in_sectionsStatement939_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_62_in_sectionsStatement946  */
static	ANTLR3_BITWORD FOLLOW_62_in_sectionsStatement946_bits[]	= { ANTLR3_UINT64_LIT(0x0004000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_62_in_sectionsStatement946	= { FOLLOW_62_in_sectionsStatement946_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SYMBOL_in_sectionsStatement948  */
static	ANTLR3_BITWORD FOLLOW_SYMBOL_in_sectionsStatement948_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000007800) };
static  ANTLR3_BITSET_LIST FOLLOW_SYMBOL_in_sectionsStatement948	= { FOLLOW_SYMBOL_in_sectionsStatement948_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_sectionsStatement950  */
static	ANTLR3_BITWORD FOLLOW_set_in_sectionsStatement950_bits[]	= { ANTLR3_UINT64_LIT(0x4000000000000002), ANTLR3_UINT64_LIT(0x0000000000007800) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_sectionsStatement950	= { FOLLOW_set_in_sectionsStatement950_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INT_in_number982  */
static	ANTLR3_BITWORD FOLLOW_INT_in_number982_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_INT_in_number982	= { FOLLOW_INT_in_number982_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_HEX_in_number991  */
static	ANTLR3_BITWORD FOLLOW_HEX_in_number991_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_HEX_in_number991	= { FOLLOW_HEX_in_number991_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_in_filename1013  */
static	ANTLR3_BITWORD FOLLOW_STRING_in_filename1013_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_in_filename1013	= { FOLLOW_STRING_in_filename1013_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_filename1018  */
static	ANTLR3_BITWORD FOLLOW_set_in_filename1018_bits[]	= { ANTLR3_UINT64_LIT(0x400E000000000002), ANTLR3_UINT64_LIT(0x0000000000018020) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_filename1018	= { FOLLOW_set_in_filename1018_bits, 2	};
     

 
 
/* ==============================================
 * Parsing rules
 */
/** 
 * $ANTLR start file
 * F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:87:1: file : ( statement )* ;
 */
static void
file(pEEDGrammarParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:88:2: ( ( statement )* )
        // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:88:4: ( statement )*
        {

            // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:88:4: ( statement )*

            for (;;)
            {
                int alt1=2;
                switch ( LA(1) ) 
                {
                case 56:
                case 57:
                case 59:
                case 61:
                case 63:
                case 70:
                case 71:
                case 72:
                case 73:
                case 74:
                	{
                		alt1=1;
                	}
                    break;

                }

                switch (alt1) 
                {
            	case 1:
            	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:88:4: statement
            	    {
            	        FOLLOWPUSH(FOLLOW_statement_in_file510);
            	        statement(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefileEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop1;	/* break out of the loop */
            	    break;
                }
            }
            loop1: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulefileEx; /* Prevent compiler warnings */
    rulefileEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end file */

/** 
 * $ANTLR start statement
 * F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:91:1: statement : ( nameStatement | baseStatement | exportStatement | versionStatement | heapsizeStatement | stacksizeStatement | stubStatement | sectionsStatement );
 */
static void
statement(pEEDGrammarParser ctx)
{   
    /* Initialize rule variables
     */


    {
        {
            //  F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:92:2: ( nameStatement | baseStatement | exportStatement | versionStatement | heapsizeStatement | stacksizeStatement | stubStatement | sectionsStatement )
            
            ANTLR3_UINT32 alt2;

            alt2=8;

            switch ( LA(1) ) 
            {
            case 56:
            case 57:
            	{
            		alt2=1;
            	}
                break;
            case 59:
            	{
            		alt2=2;
            	}
                break;
            case 63:
            	{
            		alt2=3;
            	}
                break;
            case 61:
            	{
            		alt2=4;
            	}
                break;
            case 70:
            	{
            		alt2=5;
            	}
                break;
            case 71:
            	{
            		alt2=6;
            	}
                break;
            case 72:
            	{
            		alt2=7;
            	}
                break;
            case 73:
            case 74:
            	{
            		alt2=8;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 2;
                EXCEPTION->state        = 0;


                goto rulestatementEx;
            }

            switch (alt2) 
            {
        	case 1:
        	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:92:4: nameStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_nameStatement_in_statement522);
        	        nameStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:93:4: baseStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_baseStatement_in_statement527);
        	        baseStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:94:4: exportStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_exportStatement_in_statement532);
        	        exportStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	    }
        	    break;
        	case 4:
        	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:95:4: versionStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_versionStatement_in_statement537);
        	        versionStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	    }
        	    break;
        	case 5:
        	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:96:4: heapsizeStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_heapsizeStatement_in_statement542);
        	        heapsizeStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	    }
        	    break;
        	case 6:
        	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:97:4: stacksizeStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_stacksizeStatement_in_statement547);
        	        stacksizeStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	    }
        	    break;
        	case 7:
        	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:98:4: stubStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_stubStatement_in_statement552);
        	        stubStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	    }
        	    break;
        	case 8:
        	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:99:4: sectionsStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_sectionsStatement_in_statement557);
        	        sectionsStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulestatementEx; /* Prevent compiler warnings */
    rulestatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end statement */

/** 
 * $ANTLR start nameStatement
 * F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:103:1: nameStatement : ( 'NAME' | 'LIBRARY' ) f0= filename ( ',' f= filename )* ;
 */
static void
nameStatement(pEEDGrammarParser ctx)
{   
    EEDGrammarParser_filename_return f0;
    #undef	RETURN_TYPE_f0
    #define	RETURN_TYPE_f0 EEDGrammarParser_filename_return

    EEDGrammarParser_filename_return f;
    #undef	RETURN_TYPE_f
    #define	RETURN_TYPE_f EEDGrammarParser_filename_return

    /* Initialize rule variables
     */


    g_ExportManagers.clear(); g_LoadingBases.clear();
    {
        // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:105:2: ( ( 'NAME' | 'LIBRARY' ) f0= filename ( ',' f= filename )* )
        // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:105:4: ( 'NAME' | 'LIBRARY' ) f0= filename ( ',' f= filename )*
        {
            if ( ((LA(1) >= 56) && (LA(1) <= 57)) )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else 
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_nameStatement574;
                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_nameStatement574);    goto rulenameStatementEx;
            }

            FOLLOWPUSH(FOLLOW_filename_in_nameStatement582);
            f0=filename(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulenameStatementEx;
            }

            {
                g_ExportManagers.push_back(ExportManager::GetExportManager((char*)(STRSTREAM->toStringTT(STRSTREAM, f0.start, f0.stop))->chars,true));/**/printf("NAME '%s'\n",(STRSTREAM->toStringTT(STRSTREAM, f0.start, f0.stop))->chars);/**/
            }

            // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:106:3: ( ',' f= filename )*

            for (;;)
            {
                int alt3=2;
                switch ( LA(1) ) 
                {
                case 58:
                	{
                		alt3=1;
                	}
                    break;

                }

                switch (alt3) 
                {
            	case 1:
            	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:106:4: ',' f= filename
            	    {
            	         MATCHT(58, &FOLLOW_58_in_nameStatement589); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulenameStatementEx;
            	        }

            	        FOLLOWPUSH(FOLLOW_filename_in_nameStatement593);
            	        f=filename(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulenameStatementEx;
            	        }

            	        {
            	            g_ExportManagers.push_back(ExportManager::GetExportManager((char*)(STRSTREAM->toStringTT(STRSTREAM, f.start, f.stop))->chars,true));/**/printf("NAME '%s'\n",(STRSTREAM->toStringTT(STRSTREAM, f.start, f.stop))->chars);/**/
            	        }

            	    }
            	    break;

            	default:
            	    goto loop3;	/* break out of the loop */
            	    break;
                }
            }
            loop3: ; /* Jump out to here if this rule does not match */

            {
                g_LoadingBases.resize(g_ExportManagers.size(),0);
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulenameStatementEx; /* Prevent compiler warnings */
    rulenameStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end nameStatement */

/** 
 * $ANTLR start baseStatement
 * F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:110:1: baseStatement : 'BASE' '=' n0= number ( ',' n= number )* ;
 */
static void
baseStatement(pEEDGrammarParser ctx)
{   
    long n0;
    #undef	RETURN_TYPE_n0
    #define	RETURN_TYPE_n0 long

    long n;
    #undef	RETURN_TYPE_n
    #define	RETURN_TYPE_n long

    /* Initialize rule variables
     */


    g_LoadingBases.clear();
    n0 = 0;
    n = 0;

    {
        // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:112:2: ( 'BASE' '=' n0= number ( ',' n= number )* )
        // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:112:4: 'BASE' '=' n0= number ( ',' n= number )*
        {
             MATCHT(59, &FOLLOW_59_in_baseStatement619); 
            if  (HASEXCEPTION())
            {
                goto rulebaseStatementEx;
            }

             MATCHT(60, &FOLLOW_60_in_baseStatement621); 
            if  (HASEXCEPTION())
            {
                goto rulebaseStatementEx;
            }

            FOLLOWPUSH(FOLLOW_number_in_baseStatement625);
            n0=number(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulebaseStatementEx;
            }

            {
                g_LoadingBases.push_back(n0);/**/printf("BASE <%08X>\n",n0);/**/
            }

            // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:113:3: ( ',' n= number )*

            for (;;)
            {
                int alt4=2;
                switch ( LA(1) ) 
                {
                case 58:
                	{
                		alt4=1;
                	}
                    break;

                }

                switch (alt4) 
                {
            	case 1:
            	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:113:4: ',' n= number
            	    {
            	         MATCHT(58, &FOLLOW_58_in_baseStatement633); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebaseStatementEx;
            	        }

            	        FOLLOWPUSH(FOLLOW_number_in_baseStatement637);
            	        n=number(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebaseStatementEx;
            	        }

            	        {
            	            g_LoadingBases.push_back(n);/**/printf("BASE <%08X>\n",n);/**/
            	        }

            	    }
            	    break;

            	default:
            	    goto loop4;	/* break out of the loop */
            	    break;
                }
            }
            loop4: ; /* Jump out to here if this rule does not match */

            {
                g_LoadingBases.resize(g_ExportManagers.size(),0); /* force base array to proper size with default value 0x0*/
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulebaseStatementEx; /* Prevent compiler warnings */
    rulebaseStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end baseStatement */

/** 
 * $ANTLR start versionStatement
 * F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:117:1: versionStatement : 'VERSION' '=' versionDesc ( ',' versionDesc )* ;
 */
static void
versionStatement(pEEDGrammarParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:118:2: ( 'VERSION' '=' versionDesc ( ',' versionDesc )* )
        // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:118:4: 'VERSION' '=' versionDesc ( ',' versionDesc )*
        {
             MATCHT(61, &FOLLOW_61_in_versionStatement659); 
            if  (HASEXCEPTION())
            {
                goto ruleversionStatementEx;
            }

             MATCHT(60, &FOLLOW_60_in_versionStatement661); 
            if  (HASEXCEPTION())
            {
                goto ruleversionStatementEx;
            }

            FOLLOWPUSH(FOLLOW_versionDesc_in_versionStatement662);
            versionDesc(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleversionStatementEx;
            }


            // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:118:29: ( ',' versionDesc )*

            for (;;)
            {
                int alt5=2;
                switch ( LA(1) ) 
                {
                case 58:
                	{
                		alt5=1;
                	}
                    break;

                }

                switch (alt5) 
                {
            	case 1:
            	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:118:30: ',' versionDesc
            	    {
            	         MATCHT(58, &FOLLOW_58_in_versionStatement665); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleversionStatementEx;
            	        }

            	        FOLLOWPUSH(FOLLOW_versionDesc_in_versionStatement667);
            	        versionDesc(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleversionStatementEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop5;	/* break out of the loop */
            	    break;
                }
            }
            loop5: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleversionStatementEx; /* Prevent compiler warnings */
    ruleversionStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end versionStatement */

/** 
 * $ANTLR start versionDesc
 * F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:120:1: versionDesc : INT ( '.' INT )? ;
 */
static void
versionDesc(pEEDGrammarParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:120:13: ( INT ( '.' INT )? )
        // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:120:15: INT ( '.' INT )?
        {
             MATCHT(INT, &FOLLOW_INT_in_versionDesc678); 
            if  (HASEXCEPTION())
            {
                goto ruleversionDescEx;
            }


            // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:120:19: ( '.' INT )?
            {
                int alt6=2;
                switch ( LA(1) ) 
                {
                    case 62:
                    	{
                    		alt6=1;
                    	}
                        break;
                }

                switch (alt6) 
                {
            	case 1:
            	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:120:20: '.' INT
            	    {
            	         MATCHT(62, &FOLLOW_62_in_versionDesc681); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleversionDescEx;
            	        }

            	         MATCHT(INT, &FOLLOW_INT_in_versionDesc683); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleversionDescEx;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleversionDescEx; /* Prevent compiler warnings */
    ruleversionDescEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end versionDesc */

/** 
 * $ANTLR start exportStatement
 * F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:122:1: exportStatement : 'EXPORTS' ( exportSymbol )* ;
 */
static void
exportStatement(pEEDGrammarParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:123:2: ( 'EXPORTS' ( exportSymbol )* )
        // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:123:4: 'EXPORTS' ( exportSymbol )*
        {
             MATCHT(63, &FOLLOW_63_in_exportStatement696); 
            if  (HASEXCEPTION())
            {
                goto ruleexportStatementEx;
            }


            // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:123:14: ( exportSymbol )*

            for (;;)
            {
                int alt7=2;
                switch ( LA(1) ) 
                {
                case SYMBOL:
                	{
                		alt7=1;
                	}
                    break;

                }

                switch (alt7) 
                {
            	case 1:
            	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:123:16: exportSymbol
            	    {
            	        FOLLOWPUSH(FOLLOW_exportSymbol_in_exportStatement700);
            	        exportSymbol(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexportStatementEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop7;	/* break out of the loop */
            	    break;
                }
            }
            loop7: ; /* Jump out to here if this rule does not match */

            {
                /**/printf("EXPORT DONE \n");/**/
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleexportStatementEx; /* Prevent compiler warnings */
    ruleexportStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end exportStatement */

/** 
 * $ANTLR start exportSymbol
 * F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:126:1: exportSymbol : SYMBOL ( '=' s0= symbolSource[i=0] ( ',' s= symbolSource[++i] )* )? ( '@' n0= number ( ',' n= number )* ( 'NONAME' )? )? ( 'PRIVATE' )? ( 'DATA' )? ;
 */
static void
exportSymbol(pEEDGrammarParser ctx)
{   
     std::vector<unsigned long> sources; std::vector<long> ordinals; pANTLR3_STRING symbol; int i;
    pANTLR3_COMMON_TOKEN    SYMBOL1;
    unsigned long s0;
    #undef	RETURN_TYPE_s0
    #define	RETURN_TYPE_s0 unsigned long

    unsigned long s;
    #undef	RETURN_TYPE_s
    #define	RETURN_TYPE_s unsigned long

    long n0;
    #undef	RETURN_TYPE_n0
    #define	RETURN_TYPE_n0 long

    long n;
    #undef	RETURN_TYPE_n
    #define	RETURN_TYPE_n long

    /* Initialize rule variables
     */


    SYMBOL1       = NULL;
    s0 = NULL;
    s = NULL;
    n0 = 0;
    n = 0;

    {
        // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:128:2: ( SYMBOL ( '=' s0= symbolSource[i=0] ( ',' s= symbolSource[++i] )* )? ( '@' n0= number ( ',' n= number )* ( 'NONAME' )? )? ( 'PRIVATE' )? ( 'DATA' )? )
        // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:128:4: SYMBOL ( '=' s0= symbolSource[i=0] ( ',' s= symbolSource[++i] )* )? ( '@' n0= number ( ',' n= number )* ( 'NONAME' )? )? ( 'PRIVATE' )? ( 'DATA' )?
        {
            SYMBOL1 = (pANTLR3_COMMON_TOKEN) MATCHT(SYMBOL, &FOLLOW_SYMBOL_in_exportSymbol723); 
            if  (HASEXCEPTION())
            {
                goto ruleexportSymbolEx;
            }

            {
                symbol = (SYMBOL1->getText(SYMBOL1));/**/printf("SYMBOL '%s'\n",(SYMBOL1->getText(SYMBOL1))->chars);/**/
            }

            // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:129:2: ( '=' s0= symbolSource[i=0] ( ',' s= symbolSource[++i] )* )?
            {
                int alt9=2;
                switch ( LA(1) ) 
                {
                    case 60:
                    	{
                    		alt9=1;
                    	}
                        break;
                }

                switch (alt9) 
                {
            	case 1:
            	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:129:4: '=' s0= symbolSource[i=0] ( ',' s= symbolSource[++i] )*
            	    {
            	         MATCHT(60, &FOLLOW_60_in_exportSymbol730); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexportSymbolEx;
            	        }

            	        FOLLOWPUSH(FOLLOW_symbolSource_in_exportSymbol734);
            	        s0=symbolSource(ctx, i=0);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexportSymbolEx;
            	        }

            	        {
            	            sources.push_back(s0);/**/printf("SOURCE <%08X>\n",s0);/**/
            	        }

            	        // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:130:3: ( ',' s= symbolSource[++i] )*

            	        for (;;)
            	        {
            	            int alt8=2;
            	            switch ( LA(1) ) 
            	            {
            	            case 58:
            	            	{
            	            		alt8=1;
            	            	}
            	                break;

            	            }

            	            switch (alt8) 
            	            {
            	        	case 1:
            	        	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:130:4: ',' s= symbolSource[++i]
            	        	    {
            	        	         MATCHT(58, &FOLLOW_58_in_exportSymbol743); 
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleexportSymbolEx;
            	        	        }

            	        	        FOLLOWPUSH(FOLLOW_symbolSource_in_exportSymbol747);
            	        	        s=symbolSource(ctx, ++i);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleexportSymbolEx;
            	        	        }

            	        	        {
            	        	            sources.push_back(s);/**/printf("SOURCE <%08X>\n",s);/**/
            	        	        }

            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop8;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop8: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;

                }
            }

            // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:132:2: ( '@' n0= number ( ',' n= number )* ( 'NONAME' )? )?
            {
                int alt12=2;
                switch ( LA(1) ) 
                {
                    case 64:
                    	{
                    		alt12=1;
                    	}
                        break;
                }

                switch (alt12) 
                {
            	case 1:
            	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:132:4: '@' n0= number ( ',' n= number )* ( 'NONAME' )?
            	    {
            	         MATCHT(64, &FOLLOW_64_in_exportSymbol764); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexportSymbolEx;
            	        }

            	        FOLLOWPUSH(FOLLOW_number_in_exportSymbol768);
            	        n0=number(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexportSymbolEx;
            	        }

            	        {
            	            ordinals.push_back(n0);/**/printf("ORDINAL {%i}\n",n0);/**/
            	        }

            	        // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:133:3: ( ',' n= number )*

            	        for (;;)
            	        {
            	            int alt10=2;
            	            switch ( LA(1) ) 
            	            {
            	            case 58:
            	            	{
            	            		alt10=1;
            	            	}
            	                break;

            	            }

            	            switch (alt10) 
            	            {
            	        	case 1:
            	        	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:133:4: ',' n= number
            	        	    {
            	        	         MATCHT(58, &FOLLOW_58_in_exportSymbol776); 
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleexportSymbolEx;
            	        	        }

            	        	        FOLLOWPUSH(FOLLOW_number_in_exportSymbol780);
            	        	        n=number(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleexportSymbolEx;
            	        	        }

            	        	        {
            	        	            ordinals.push_back(n);/**/printf("ORDINAL {%i}\n",n);/**/
            	        	        }

            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop10;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop10: ; /* Jump out to here if this rule does not match */


            	        // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:134:3: ( 'NONAME' )?
            	        {
            	            int alt11=2;
            	            switch ( LA(1) ) 
            	            {
            	                case 65:
            	                	{
            	                		alt11=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt11) 
            	            {
            	        	case 1:
            	        	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:134:5: 'NONAME'
            	        	    {
            	        	         MATCHT(65, &FOLLOW_65_in_exportSymbol792); 
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleexportSymbolEx;
            	        	        }

            	        	        {
            	        	            symbol = NULL;/**/printf("SYMBOL NONAME \n");/**/
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

            // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:136:2: ( 'PRIVATE' )?
            {
                int alt13=2;
                switch ( LA(1) ) 
                {
                    case 66:
                    	{
                    		alt13=1;
                    	}
                        break;
                }

                switch (alt13) 
                {
            	case 1:
            	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:136:2: 'PRIVATE'
            	    {
            	         MATCHT(66, &FOLLOW_66_in_exportSymbol806); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexportSymbolEx;
            	        }


            	    }
            	    break;

                }
            }

            // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:136:13: ( 'DATA' )?
            {
                int alt14=2;
                switch ( LA(1) ) 
                {
                    case 67:
                    	{
                    		alt14=1;
                    	}
                        break;
                }

                switch (alt14) 
                {
            	case 1:
            	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:136:13: 'DATA'
            	    {
            	         MATCHT(67, &FOLLOW_67_in_exportSymbol809); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexportSymbolEx;
            	        }


            	    }
            	    break;

                }
            }
            {

                		sources.resize(g_ExportManagers.size(),0);		// force source addr array to proper size with default value 0x0
                		ordinals.resize(g_ExportManagers.size(),-1);	// force ordinal array to proper size with default value -1
                		for (i = 0; i < g_ExportManagers.size(); i++)
                		{
                			// for each export manager, determine source address and ordinal and add to manager's export table
                			ordinals[i] = g_ExportManagers[i]->ExportFunc((FARPROC)sources[i],ordinals[i]);
                			if (symbol && ordinals[i] >= 0) g_ExportManagers[i]->ExportName((char*)symbol->chars,ordinals[i]);
                		}
                	
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleexportSymbolEx; /* Prevent compiler warnings */
    ruleexportSymbolEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end exportSymbol */

/** 
 * $ANTLR start symbolSource
 * F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:149:1: symbolSource[unsigned long idxModule] returns [unsigned long addr] : ( ( '#' )? number | SYMBOL ( ':' filename )? );
 */
static unsigned long
symbolSource(pEEDGrammarParser ctx, unsigned long idxModule)
{   
    unsigned long addr = NULL;

    	
    	HMODULE srcModule = 0; addr= 0; 
    	if (idxModule < g_ExportManagers.size()) 
    	{
    		// valid module index
    		srcModule = g_ExportManagers[idxModule]->GetModule(); 
    		addr -=g_LoadingBases[idxModule]; 
    	}

    pANTLR3_COMMON_TOKEN    SYMBOL4;
    long number2;
    #undef	RETURN_TYPE_number2
    #define	RETURN_TYPE_number2 long

    EEDGrammarParser_filename_return filename3;
    #undef	RETURN_TYPE_filename3
    #define	RETURN_TYPE_filename3 EEDGrammarParser_filename_return

    /* Initialize rule variables
     */


    SYMBOL4       = NULL;
    number2 = 0;

    {
        {
            //  F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:160:2: ( ( '#' )? number | SYMBOL ( ':' filename )? )
            
            ANTLR3_UINT32 alt17;

            alt17=2;

            switch ( LA(1) ) 
            {
            case INT:
            case HEX:
            case 68:
            	{
            		alt17=1;
            	}
                break;
            case SYMBOL:
            	{
            		alt17=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 17;
                EXCEPTION->state        = 0;


                goto rulesymbolSourceEx;
            }

            switch (alt17) 
            {
        	case 1:
        	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:160:4: ( '#' )? number
        	    {

        	        // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:160:4: ( '#' )?
        	        {
        	            int alt15=2;
        	            switch ( LA(1) ) 
        	            {
        	                case 68:
        	                	{
        	                		alt15=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt15) 
        	            {
        	        	case 1:
        	        	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:160:5: '#'
        	        	    {
        	        	         MATCHT(68, &FOLLOW_68_in_symbolSource837); 
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesymbolSourceEx;
        	        	        }

        	        	        {
        	        	            addr= 0;
        	        	        }

        	        	    }
        	        	    break;

        	            }
        	        }
        	        FOLLOWPUSH(FOLLOW_number_in_symbolSource844);
        	        number2=number(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesymbolSourceEx;
        	        }

        	        {
        	            addr += number2 + (unsigned long)srcModule;/**/printf("SOURCEADDR <%08X>\n",number2);/**/
        	        }

        	    }
        	    break;
        	case 2:
        	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:161:4: SYMBOL ( ':' filename )?
        	    {
        	        SYMBOL4 = (pANTLR3_COMMON_TOKEN) MATCHT(SYMBOL, &FOLLOW_SYMBOL_in_symbolSource851); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulesymbolSourceEx;
        	        }


        	        // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:161:11: ( ':' filename )?
        	        {
        	            int alt16=2;
        	            switch ( LA(1) ) 
        	            {
        	                case 69:
        	                	{
        	                		alt16=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt16) 
        	            {
        	        	case 1:
        	        	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:161:12: ':' filename
        	        	    {
        	        	         MATCHT(69, &FOLLOW_69_in_symbolSource854); 
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesymbolSourceEx;
        	        	        }

        	        	        FOLLOWPUSH(FOLLOW_filename_in_symbolSource856);
        	        	        filename3=filename(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulesymbolSourceEx;
        	        	        }

        	        	        {
        	        	            srcModule = GetModuleHandle((char*)(STRSTREAM->toStringTT(STRSTREAM, filename3.start, filename3.stop))->chars);/**/printf("SOURCEMODULE '%s'\n",(STRSTREAM->toStringTT(STRSTREAM, filename3.start, filename3.stop))->chars);/**/
        	        	        }

        	        	    }
        	        	    break;

        	            }
        	        }
        	        {
        	            addr= srcModule ? (unsigned long)GetProcAddress(srcModule,(char*)(SYMBOL4->getText(SYMBOL4))->chars) : 0;/**/printf("SOURCESYMBOL '%s'\n",(SYMBOL4->getText(SYMBOL4))->chars);/**/
        	        }

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulesymbolSourceEx; /* Prevent compiler warnings */
    rulesymbolSourceEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return addr;
}
/* $ANTLR end symbolSource */

/** 
 * $ANTLR start heapsizeStatement
 * F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:166:1: heapsizeStatement : 'HEAPSIZE' '=' number ( ',' number )? ;
 */
static void
heapsizeStatement(pEEDGrammarParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:167:2: ( 'HEAPSIZE' '=' number ( ',' number )? )
        // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:167:4: 'HEAPSIZE' '=' number ( ',' number )?
        {
             MATCHT(70, &FOLLOW_70_in_heapsizeStatement878); 
            if  (HASEXCEPTION())
            {
                goto ruleheapsizeStatementEx;
            }

             MATCHT(60, &FOLLOW_60_in_heapsizeStatement880); 
            if  (HASEXCEPTION())
            {
                goto ruleheapsizeStatementEx;
            }

            FOLLOWPUSH(FOLLOW_number_in_heapsizeStatement882);
            number(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleheapsizeStatementEx;
            }


            // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:167:26: ( ',' number )?
            {
                int alt18=2;
                switch ( LA(1) ) 
                {
                    case 58:
                    	{
                    		alt18=1;
                    	}
                        break;
                }

                switch (alt18) 
                {
            	case 1:
            	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:167:27: ',' number
            	    {
            	         MATCHT(58, &FOLLOW_58_in_heapsizeStatement885); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleheapsizeStatementEx;
            	        }

            	        FOLLOWPUSH(FOLLOW_number_in_heapsizeStatement887);
            	        number(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleheapsizeStatementEx;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleheapsizeStatementEx; /* Prevent compiler warnings */
    ruleheapsizeStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end heapsizeStatement */

/** 
 * $ANTLR start stacksizeStatement
 * F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:170:1: stacksizeStatement : 'STACKSIZE' '=' number ( ',' number )? ;
 */
static void
stacksizeStatement(pEEDGrammarParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:171:2: ( 'STACKSIZE' '=' number ( ',' number )? )
        // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:171:4: 'STACKSIZE' '=' number ( ',' number )?
        {
             MATCHT(71, &FOLLOW_71_in_stacksizeStatement901); 
            if  (HASEXCEPTION())
            {
                goto rulestacksizeStatementEx;
            }

             MATCHT(60, &FOLLOW_60_in_stacksizeStatement903); 
            if  (HASEXCEPTION())
            {
                goto rulestacksizeStatementEx;
            }

            FOLLOWPUSH(FOLLOW_number_in_stacksizeStatement905);
            number(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulestacksizeStatementEx;
            }


            // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:171:27: ( ',' number )?
            {
                int alt19=2;
                switch ( LA(1) ) 
                {
                    case 58:
                    	{
                    		alt19=1;
                    	}
                        break;
                }

                switch (alt19) 
                {
            	case 1:
            	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:171:28: ',' number
            	    {
            	         MATCHT(58, &FOLLOW_58_in_stacksizeStatement908); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulestacksizeStatementEx;
            	        }

            	        FOLLOWPUSH(FOLLOW_number_in_stacksizeStatement910);
            	        number(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulestacksizeStatementEx;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulestacksizeStatementEx; /* Prevent compiler warnings */
    rulestacksizeStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end stacksizeStatement */

/** 
 * $ANTLR start stubStatement
 * F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:174:1: stubStatement : 'STUB' filename ;
 */
static void
stubStatement(pEEDGrammarParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:175:2: ( 'STUB' filename )
        // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:175:4: 'STUB' filename
        {
             MATCHT(72, &FOLLOW_72_in_stubStatement924); 
            if  (HASEXCEPTION())
            {
                goto rulestubStatementEx;
            }

            FOLLOWPUSH(FOLLOW_filename_in_stubStatement926);
            filename(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulestubStatementEx;
            }


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulestubStatementEx; /* Prevent compiler warnings */
    rulestubStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end stubStatement */

/** 
 * $ANTLR start sectionsStatement
 * F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:178:1: sectionsStatement : ( 'SECTIONS' | 'SEGMENTS' ) ( '.' SYMBOL ( 'READ' | 'WRITE' | 'EXECUTE' | 'SHARED' )+ )+ ;
 */
static void
sectionsStatement(pEEDGrammarParser ctx)
{   
    /* Initialize rule variables
     */


    {
        // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:179:2: ( ( 'SECTIONS' | 'SEGMENTS' ) ( '.' SYMBOL ( 'READ' | 'WRITE' | 'EXECUTE' | 'SHARED' )+ )+ )
        // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:179:4: ( 'SECTIONS' | 'SEGMENTS' ) ( '.' SYMBOL ( 'READ' | 'WRITE' | 'EXECUTE' | 'SHARED' )+ )+
        {
            if ( ((LA(1) >= 73) && (LA(1) <= 74)) )
            {
                CONSUME();
                PERRORRECOVERY=ANTLR3_FALSE;
            }
            else 
            {
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = &FOLLOW_set_in_sectionsStatement939;
                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_sectionsStatement939);    goto rulesectionsStatementEx;
            }

            // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:179:28: ( '.' SYMBOL ( 'READ' | 'WRITE' | 'EXECUTE' | 'SHARED' )+ )+
            {
                int cnt21=0;

                for (;;)
                {
                    int alt21=2;
            	switch ( LA(1) ) 
            	{
            	case 62:
            		{
            			alt21=1;
            		}
            	    break;

            	}

            	switch (alt21) 
            	{
            	    case 1:
            	        // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:179:29: '.' SYMBOL ( 'READ' | 'WRITE' | 'EXECUTE' | 'SHARED' )+
            	        {
            	             MATCHT(62, &FOLLOW_62_in_sectionsStatement946); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulesectionsStatementEx;
            	            }

            	             MATCHT(SYMBOL, &FOLLOW_SYMBOL_in_sectionsStatement948); 
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulesectionsStatementEx;
            	            }

            	            // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:179:40: ( 'READ' | 'WRITE' | 'EXECUTE' | 'SHARED' )+
            	            {
            	                int cnt20=0;

            	                for (;;)
            	                {
            	                    int alt20=2;
            	            	switch ( LA(1) ) 
            	            	{
            	            	case 75:
            	            	case 76:
            	            	case 77:
            	            	case 78:
            	            		{
            	            			alt20=1;
            	            		}
            	            	    break;

            	            	}

            	            	switch (alt20) 
            	            	{
            	            	    case 1:
            	            	        // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:
            	            	        {
            	            	            if ( ((LA(1) >= 75) && (LA(1) <= 78)) )
            	            	            {
            	            	                CONSUME();
            	            	                PERRORRECOVERY=ANTLR3_FALSE;
            	            	            }
            	            	            else 
            	            	            {
            	            	                CONSTRUCTEX();
            	            	                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            	            	                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
            	            	                EXCEPTION->expectingSet = &FOLLOW_set_in_sectionsStatement950;
            	            	                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_sectionsStatement950);    goto rulesectionsStatementEx;
            	            	            }


            	            	        }
            	            	        break;

            	            	    default:
            	            	    
            	            		if ( cnt20 >= 1 )
            	            		{
            	            		    goto loop20;
            	            		}
            	            		/* mismatchedSetEx()
            	            		 */
            	            		CONSTRUCTEX();
            	            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            	            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            	            		goto rulesectionsStatementEx;
            	            	}
            	            	cnt20++;
            	                }
            	                loop20: ;	/* Jump to here if this rule does not match */
            	            }

            	        }
            	        break;

            	    default:
            	    
            		if ( cnt21 >= 1 )
            		{
            		    goto loop21;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulesectionsStatementEx;
            	}
            	cnt21++;
                }
                loop21: ;	/* Jump to here if this rule does not match */
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulesectionsStatementEx; /* Prevent compiler warnings */
    rulesectionsStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return ;
}
/* $ANTLR end sectionsStatement */

/** 
 * $ANTLR start number
 * F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:183:1: number returns [long value] : ( INT | HEX ) ;
 */
static long
number(pEEDGrammarParser ctx)
{   
    long value = 0;

    pANTLR3_COMMON_TOKEN    INT5;
    pANTLR3_COMMON_TOKEN    HEX6;

    /* Initialize rule variables
     */


    INT5       = NULL;
    HEX6       = NULL;

    {
        // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:184:2: ( ( INT | HEX ) )
        // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:185:2: ( INT | HEX )
        {

            // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:185:2: ( INT | HEX )
            {
                int alt22=2;
                switch ( LA(1) ) 
                {
                case INT:
                	{
                		alt22=1;
                	}
                    break;
                case HEX:
                	{
                		alt22=2;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 22;
                    EXCEPTION->state        = 0;


                    goto rulenumberEx;
                }

                switch (alt22) 
                {
            	case 1:
            	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:185:4: INT
            	    {
            	        INT5 = (pANTLR3_COMMON_TOKEN) MATCHT(INT, &FOLLOW_INT_in_number982); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulenumberEx;
            	        }

            	        {
            	            value= strtol((char*)(INT5->getText(INT5))->chars,NULL,10);
            	        }

            	    }
            	    break;
            	case 2:
            	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:186:4: HEX
            	    {
            	        HEX6 = (pANTLR3_COMMON_TOKEN) MATCHT(HEX, &FOLLOW_HEX_in_number991); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulenumberEx;
            	        }

            	        {
            	            value= strtol((char*)(HEX6->getText(HEX6))->chars,NULL,16);
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulenumberEx; /* Prevent compiler warnings */
    rulenumberEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return value;
}
/* $ANTLR end number */

/** 
 * $ANTLR start filename
 * F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:190:1: filename : ( STRING | ( SYMBOL | '.' | ':' | '\\\\' | '/' | INT | HEX )+ ) ;
 */
static EEDGrammarParser_filename_return
filename(pEEDGrammarParser ctx)
{   
    EEDGrammarParser_filename_return retval;

    /* Initialize rule variables
     */


    retval.start = LT(1); retval.stop = retval.start;

    {
        // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:191:2: ( ( STRING | ( SYMBOL | '.' | ':' | '\\\\' | '/' | INT | HEX )+ ) )
        // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:192:2: ( STRING | ( SYMBOL | '.' | ':' | '\\\\' | '/' | INT | HEX )+ )
        {

            // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:192:2: ( STRING | ( SYMBOL | '.' | ':' | '\\\\' | '/' | INT | HEX )+ )
            {
                int alt24=2;
                switch ( LA(1) ) 
                {
                case STRING:
                	{
                		alt24=1;
                	}
                    break;
                case INT:
                case SYMBOL:
                case HEX:
                case 62:
                case 69:
                case 79:
                case 80:
                	{
                		alt24=2;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 24;
                    EXCEPTION->state        = 0;


                    goto rulefilenameEx;
                }

                switch (alt24) 
                {
            	case 1:
            	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:192:4: STRING
            	    {
            	         MATCHT(STRING, &FOLLOW_STRING_in_filename1013); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefilenameEx;
            	        }


            	    }
            	    break;
            	case 2:
            	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:193:4: ( SYMBOL | '.' | ':' | '\\\\' | '/' | INT | HEX )+
            	    {
            	        // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:193:4: ( SYMBOL | '.' | ':' | '\\\\' | '/' | INT | HEX )+
            	        {
            	            int cnt23=0;

            	            for (;;)
            	            {
            	                int alt23=2;
            	        	switch ( LA(1) ) 
            	        	{
            	        	case INT:
            	        	case SYMBOL:
            	        	case HEX:
            	        	case 62:
            	        	case 69:
            	        	case 79:
            	        	case 80:
            	        		{
            	        			alt23=1;
            	        		}
            	        	    break;

            	        	}

            	        	switch (alt23) 
            	        	{
            	        	    case 1:
            	        	        // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:
            	        	        {
            	        	            if ( ((LA(1) >= INT) && (LA(1) <= HEX)) || LA(1) == 62 || LA(1) == 69 || ((LA(1) >= 79) && (LA(1) <= 80)) )
            	        	            {
            	        	                CONSUME();
            	        	                PERRORRECOVERY=ANTLR3_FALSE;
            	        	            }
            	        	            else 
            	        	            {
            	        	                CONSTRUCTEX();
            	        	                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            	        	                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
            	        	                EXCEPTION->expectingSet = &FOLLOW_set_in_filename1018;
            	        	                RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_filename1018);    goto rulefilenameEx;
            	        	            }


            	        	        }
            	        	        break;

            	        	    default:
            	        	    
            	        		if ( cnt23 >= 1 )
            	        		{
            	        		    goto loop23;
            	        		}
            	        		/* mismatchedSetEx()
            	        		 */
            	        		CONSTRUCTEX();
            	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            	        		goto rulefilenameEx;
            	        	}
            	        	cnt23++;
            	            }
            	            loop23: ;	/* Jump to here if this rule does not match */
            	        }

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulefilenameEx; /* Prevent compiler warnings */
    rulefilenameEx: ;
    retval.stop = LT(-1);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }


    return retval;
}
/* $ANTLR end filename */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */

 
 



/* End of code
 * =============================================================================
 */
