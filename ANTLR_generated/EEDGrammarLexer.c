/** \file
 *  This C source file was generated by $ANTLR version 3.2 Sep 23, 2009 12:02:23
 *
 *     -  From the grammar source file : F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g
 *     -                            On : 2010-11-13 20:24:14
 *     -                 for the lexer : EEDGrammarLexerLexer *
 * Editing it, at least manually, is not wise. 
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD licence"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "EEDGrammarLexer.h"
/* ----------------------------------------- */


/** String literals used by EEDGrammarLexer that we must do things like MATCHS() with.
 *  C will normally just lay down 8 bit characters, and you can use L"xxx" to
 *  get wchar_t, but wchar_t is 16 bits on Windows, which is not UTF32 and so
 *  we perform this little trick of defining the literals as arrays of UINT32
 *  and passing in the address of these.
 */
static ANTLR3_UCHAR	lit_1[]  = { 0x41, 0x50, 0x50, 0x4C, 0x4F, 0x41, 0x44, 0x45, 0x52,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_2[]  = { 0x43, 0x4F, 0x44, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_3[]  = { 0x43, 0x4F, 0x4E, 0x46, 0x4F, 0x52, 0x4D, 0x49, 0x4E, 0x47,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_4[]  = { 0x44, 0x45, 0x53, 0x43, 0x52, 0x49, 0x50, 0x54, 0x49, 0x4F, 0x4E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_5[]  = { 0x44, 0x45, 0x56, 0x33, 0x38, 0x36,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_6[]  = { 0x44, 0x49, 0x53, 0x43, 0x41, 0x52, 0x44, 0x41, 0x42, 0x4C, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_7[]  = { 0x44, 0x59, 0x4E, 0x41, 0x4D, 0x49, 0x43,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_8[]  = { 0x45, 0x58, 0x45, 0x43, 0x55, 0x54, 0x45, 0x2D, 0x4F, 0x4E, 0x4C, 0x59,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_9[]  = { 0x45, 0x58, 0x45, 0x43, 0x55, 0x54, 0x45, 0x4F, 0x4E, 0x4C, 0x59,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_10[]  = { 0x45, 0x58, 0x45, 0x43, 0x55, 0x54, 0x45, 0x52, 0x45, 0x41, 0x44,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_11[]  = { 0x45, 0x58, 0x45, 0x54, 0x59, 0x50, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_12[]  = { 0x46, 0x49, 0x58, 0x45, 0x44,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_13[]  = { 0x46, 0x55, 0x4E, 0x43, 0x54, 0x49, 0x4F, 0x4E, 0x53,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_14[]  = { 0x49, 0x4D, 0x50, 0x4F, 0x52, 0x54, 0x53,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_15[]  = { 0x49, 0x4D, 0x50, 0x55, 0x52, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_16[]  = { 0x49, 0x4E, 0x43, 0x4C, 0x55, 0x44, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_17[]  = { 0x49, 0x4E, 0x49, 0x54, 0x49, 0x4E, 0x53, 0x54, 0x41, 0x4E, 0x43, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_18[]  = { 0x49, 0x4F, 0x50, 0x4C,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_19[]  = { 0x4C, 0x4F, 0x41, 0x44, 0x4F, 0x4E, 0x43, 0x41, 0x4C, 0x4C,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_20[]  = { 0x4C, 0x4F, 0x4E, 0x47, 0x4E, 0x41, 0x4D, 0x45, 0x53,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_21[]  = { 0x4D, 0x4F, 0x56, 0x41, 0x42, 0x4C, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_22[]  = { 0x4D, 0x4F, 0x56, 0x45, 0x41, 0x42, 0x4C, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_23[]  = { 0x4D, 0x55, 0x4C, 0x54, 0x49, 0x50, 0x4C, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_24[]  = { 0x4E, 0x45, 0x57, 0x46, 0x49, 0x4C, 0x45, 0x53,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_25[]  = { 0x4E, 0x4F, 0x44, 0x41, 0x54, 0x41,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_26[]  = { 0x4E, 0x4F, 0x49, 0x4F, 0x50, 0x4C,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_27[]  = { 0x4E, 0x4F, 0x4E, 0x43, 0x4F, 0x4E, 0x46, 0x4F, 0x52, 0x4D, 0x49, 0x4E, 0x47,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_28[]  = { 0x4E, 0x4F, 0x4E, 0x44, 0x49, 0x53, 0x43, 0x41, 0x52, 0x44, 0x41, 0x42, 0x4C, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_29[]  = { 0x4E, 0x4F, 0x4E, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_30[]  = { 0x4E, 0x4F, 0x4E, 0x53, 0x48, 0x41, 0x52, 0x45, 0x44,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_31[]  = { 0x4E, 0x4F, 0x54, 0x57, 0x49, 0x4E, 0x44, 0x4F, 0x57, 0x43, 0x4F, 0x4D, 0x50, 0x41, 0x54,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_32[]  = { 0x4F, 0x42, 0x4A, 0x45, 0x43, 0x54, 0x53,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_33[]  = { 0x4F, 0x4C, 0x44,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_34[]  = { 0x50, 0x52, 0x45, 0x4C, 0x4F, 0x41, 0x44,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_35[]  = { 0x50, 0x52, 0x4F, 0x54, 0x4D, 0x4F, 0x44, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_36[]  = { 0x50, 0x55, 0x52, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_37[]  = { 0x52, 0x45, 0x41, 0x44, 0x4F, 0x4E, 0x4C, 0x59,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_38[]  = { 0x52, 0x45, 0x41, 0x44, 0x57, 0x52, 0x49, 0x54, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_39[]  = { 0x52, 0x45, 0x41, 0x4C, 0x4D, 0x4F, 0x44, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_40[]  = { 0x52, 0x45, 0x53, 0x49, 0x44, 0x45, 0x4E, 0x54,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_41[]  = { 0x52, 0x45, 0x53, 0x49, 0x44, 0x45, 0x4E, 0x54, 0x4E, 0x41, 0x4D, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_42[]  = { 0x53, 0x49, 0x4E, 0x47, 0x4C, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_43[]  = { 0x57, 0x49, 0x4E, 0x44, 0x4F, 0x57, 0x41, 0x50, 0x49,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_44[]  = { 0x57, 0x49, 0x4E, 0x44, 0x4F, 0x57, 0x43, 0x4F, 0x4D, 0x50, 0x41, 0x54,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_45[]  = { 0x57, 0x49, 0x4E, 0x44, 0x4F, 0x57, 0x53,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_46[]  = { 0x4E, 0x41, 0x4D, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_47[]  = { 0x4C, 0x49, 0x42, 0x52, 0x41, 0x52, 0x59,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_48[]  = { 0x42, 0x41, 0x53, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_49[]  = { 0x56, 0x45, 0x52, 0x53, 0x49, 0x4F, 0x4E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_50[]  = { 0x45, 0x58, 0x50, 0x4F, 0x52, 0x54, 0x53,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_51[]  = { 0x4E, 0x4F, 0x4E, 0x41, 0x4D, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_52[]  = { 0x50, 0x52, 0x49, 0x56, 0x41, 0x54, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_53[]  = { 0x44, 0x41, 0x54, 0x41,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_54[]  = { 0x48, 0x45, 0x41, 0x50, 0x53, 0x49, 0x5A, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_55[]  = { 0x53, 0x54, 0x41, 0x43, 0x4B, 0x53, 0x49, 0x5A, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_56[]  = { 0x53, 0x54, 0x55, 0x42,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_57[]  = { 0x53, 0x45, 0x43, 0x54, 0x49, 0x4F, 0x4E, 0x53,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_58[]  = { 0x53, 0x45, 0x47, 0x4D, 0x45, 0x4E, 0x54, 0x53,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_59[]  = { 0x52, 0x45, 0x41, 0x44,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_60[]  = { 0x57, 0x52, 0x49, 0x54, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_61[]  = { 0x45, 0x58, 0x45, 0x43, 0x55, 0x54, 0x45,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_62[]  = { 0x53, 0x48, 0x41, 0x52, 0x45, 0x44,  ANTLR3_STRING_TERMINATOR};




/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */
 
#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pEEDGrammarLexer_##scope##_SCOPE
#define SCOPE_STACK(scope)  pEEDGrammarLexer_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pEEDGrammarLexer_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pEEDGrammarLexer_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

 
/* Macros for accessing things in a lexer
 */
#undef	    LEXER
#undef	    RECOGNIZER		    
#undef	    RULEMEMO		    
#undef	    GETCHARINDEX
#undef	    GETLINE
#undef	    GETCHARPOSITIONINLINE
#undef	    EMIT
#undef	    EMITNEW
#undef	    MATCHC
#undef	    MATCHS
#undef	    MATCHRANGE
#undef	    LTOKEN
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    INPUT
#undef	    STRSTREAM
#undef	    LA
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    LRECOVER
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    BACKTRACKING
#undef		MATCHANY
#undef		MEMOIZE
#undef		HAVEPARSEDRULE
#undef		GETTEXT
#undef		INDEX
#undef		SEEK
#undef		PUSHSTREAM
#undef		POPSTREAM
#undef		SETTEXT
#undef		SETTEXT8

#define	    LEXER					ctx->pLexer
#define	    RECOGNIZER			    LEXER->rec
#define		LEXSTATE				RECOGNIZER->state
#define		TOKSOURCE				LEXSTATE->tokSource
#define	    GETCHARINDEX()			LEXER->getCharIndex(LEXER)
#define	    GETLINE()				LEXER->getLine(LEXER)
#define	    GETTEXT()				LEXER->getText(LEXER)
#define	    GETCHARPOSITIONINLINE() LEXER->getCharPositionInLine(LEXER)
#define	    EMIT()					LEXSTATE->type = _type; LEXER->emit(LEXER)
#define	    EMITNEW(t)				LEXER->emitNew(LEXER, t)
#define	    MATCHC(c)				LEXER->matchc(LEXER, c)
#define	    MATCHS(s)				LEXER->matchs(LEXER, s)
#define	    MATCHRANGE(c1,c2)	    LEXER->matchRange(LEXER, c1, c2)
#define	    MATCHANY()				LEXER->matchAny(LEXER)
#define	    LTOKEN  				LEXSTATE->token
#define	    HASFAILED()				(LEXSTATE->failed == ANTLR3_TRUE)
#define	    BACKTRACKING			LEXSTATE->backtracking
#define	    FAILEDFLAG				LEXSTATE->failed
#define	    INPUT					LEXER->input
#define	    STRSTREAM				INPUT
#define		ISTREAM					INPUT->istream
#define		INDEX()					ISTREAM->index(ISTREAM)
#define		SEEK(n)					ISTREAM->seek(ISTREAM, n)
#define	    EOF_TOKEN				&(LEXSTATE->tokSource->eofToken)
#define	    HASEXCEPTION()			(LEXSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION				LEXSTATE->exception
#define	    CONSTRUCTEX()			RECOGNIZER->exConstruct(RECOGNIZER)
#define	    LRECOVER()				LEXER->recover(LEXER)
#define	    MARK()					ISTREAM->mark(ISTREAM)
#define	    REWIND(m)				ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()			ISTREAM->rewindLast(ISTREAM)
#define		MEMOIZE(ri,si)			RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define		HAVEPARSEDRULE(r)		RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define		PUSHSTREAM(str)			LEXER->pushCharStream(LEXER, str)
#define		POPSTREAM()				LEXER->popCharStream(LEXER)
#define		SETTEXT(str)			LEXSTATE->text = str
#define		SKIP()					LEXSTATE->token = &(TOKSOURCE->skipToken)
#define		USER1					LEXSTATE->user1
#define		USER2					LEXSTATE->user2
#define		USER3					LEXSTATE->user3
#define		CUSTOM					LEXSTATE->custom
#define		RULEMEMO				LEXSTATE->ruleMemo
#define		DBG						RECOGNIZER->debugger

/* If we have been told we can rely on the standard 8 bit or 16 bit input
 * stream, then we can define our macros to use the direct pointers
 * in the input object, which is much faster than indirect calls. This
 * is really only significant to lexers with a lot of fragment rules (which
 * do not place LA(1) in a temporary at the moment) and even then
 * only if there is a lot of input (order of say 1M or so).
 */
#if	defined(ANTLR3_INLINE_INPUT_ASCII) || defined(ANTLR3_INLINE_INPUT_UTF16)

# ifdef	ANTLR3_INLINE_INPUT_ASCII

/* 8 bit "ASCII" (actually any 8 bit character set) */

#  define	    NEXTCHAR			((pANTLR3_UINT8)(INPUT->nextChar))
#  define	    DATAP				((pANTLR3_UINT8)(INPUT->data))

# else

#  define	    NEXTCHAR			((pANTLR3_UINT16)(INPUT->nextChar)) 
#  define	    DATAP				((pANTLR3_UINT16)(INPUT->data))

# endif

# define	    LA(n) ((NEXTCHAR + n) > (DATAP + INPUT->sizeBuf) ? ANTLR3_CHARSTREAM_EOF : (ANTLR3_UCHAR)(*(NEXTCHAR + n - 1)))
# define	    CONSUME()											\
{																	\
    if	(NEXTCHAR < (DATAP + INPUT->sizeBuf))						\
    {																\
		INPUT->charPositionInLine++;								\
		if  ((ANTLR3_UCHAR)(*NEXTCHAR) == INPUT->newlineChar)		\
		{															\
			INPUT->line++;											\
			INPUT->charPositionInLine	= 0;						\
			INPUT->currentLine		= (void *)(NEXTCHAR + 1);		\
		}															\
		INPUT->nextChar = (void *)(NEXTCHAR + 1);					\
    }																\
}

#else

// Pick up the input character by calling the input stream implementation.
//
#define	    CONSUME()				INPUT->istream->consume(INPUT->istream)
#define	    LA(n)					INPUT->istream->_LA(INPUT->istream, n)

#endif
#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */


/* Forward declare the locally static matching functions we have generated and any predicate functions.
 */
static ANTLR3_INLINE  void	mAPPLOADER    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mCODE    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mCONFORMING    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mDESCRIPTION    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mDEV386    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mDISCARDABLE    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mDYNAMIC    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mEXECUTE_ONLY    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mEXECUTEONLY    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mEXECUTEREAD    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mEXETYPE    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mFIXED    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mFUNCTIONS    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mIMPORTS    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mIMPURE    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mINCLUDE    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mINITINSTANCE    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mIOPL    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mLOADONCALL    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mLONGNAMES    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mMOVABLE    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mMOVEABLE    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mMULTIPLE    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mNEWFILES    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mNODATA    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mNOIOPL    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mNONCONFORMING    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mNONDISCARDABLE    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mNONE    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mNONSHARED    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mNOTWINDOWCOMPAT    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mOBJECTS    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mOLD    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mPRELOAD    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mPROTMODE    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mPURE    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mREADONLY    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mREADWRITE    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mREALMODE    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mRESIDENT    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mRESIDENTNAME    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mSINGLE    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mWINDOWAPI    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mWINDOWCOMPAT    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mWINDOWS    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mT__56    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mT__57    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mT__58    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mT__59    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mT__60    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mT__61    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mT__62    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mT__63    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mT__64    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mT__65    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mT__66    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mT__67    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mT__68    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mT__69    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mT__70    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mT__71    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mT__72    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mT__73    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mT__74    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mT__75    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mT__76    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mT__77    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mT__78    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mT__79    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mT__80    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mCOMMENT    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mSTRING    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mHEX    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mINT    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mSYMBOL    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mWSTOKEN    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mWHITESPACE    (pEEDGrammarLexer ctx);
static ANTLR3_INLINE  void	mTokens    (pEEDGrammarLexer ctx);
static void	EEDGrammarLexerFree(pEEDGrammarLexer ctx);

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */



static void
EEDGrammarLexerFree  (pEEDGrammarLexer ctx)
{
    LEXER->free(LEXER);
    
    ANTLR3_FREE(ctx);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}

/** \brief Create a new lexer called EEDGrammarLexer
 *
 * \param[in]    instream Pointer to an initialized input stream
 * \return 
 *     - Success pEEDGrammarLexer initialized for the lex start
 *     - Fail NULL
 */
ANTLR3_API pEEDGrammarLexer EEDGrammarLexerNew         
(pANTLR3_INPUT_STREAM instream)
{
	// See if we can create a new lexer with the standard constructor
	//
	return EEDGrammarLexerNewSSD(instream, NULL);
}

/** \brief Create a new lexer called EEDGrammarLexer
 *
 * \param[in]    instream Pointer to an initialized input stream
 * \param[state] state Previously created shared recognizer stat
 * \return 
 *     - Success pEEDGrammarLexer initialized for the lex start
 *     - Fail NULL
 */
ANTLR3_API pEEDGrammarLexer EEDGrammarLexerNewSSD         
(pANTLR3_INPUT_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pEEDGrammarLexer ctx; // Context structure we will build and return

    ctx = (pEEDGrammarLexer) ANTLR3_CALLOC(1, sizeof(EEDGrammarLexer));

    if  (ctx == NULL)
    {
        // Failed to allocate memory for lexer context
        return  NULL;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * in base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 lexer function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function. 
     *
     * We don't use the macros defined in EEDGrammarLexer.h here so you can get a sense
     * of what goes where.
     */
    
    /* Create a base lexer, using the supplied input stream
     */
    ctx->pLexer	= antlr3LexerNewStream(ANTLR3_SIZE_HINT, instream, state);
    
    /* Check that we allocated the memory correctly
     */
    if	(ctx->pLexer == NULL)
    {
		ANTLR3_FREE(ctx);
		return  NULL;
    }
    /* Install the implementation of our EEDGrammarLexer interface
     */
    ctx->mAPPLOADER	= mAPPLOADER;
    ctx->mCODE	= mCODE;
    ctx->mCONFORMING	= mCONFORMING;
    ctx->mDESCRIPTION	= mDESCRIPTION;
    ctx->mDEV386	= mDEV386;
    ctx->mDISCARDABLE	= mDISCARDABLE;
    ctx->mDYNAMIC	= mDYNAMIC;
    ctx->mEXECUTE_ONLY	= mEXECUTE_ONLY;
    ctx->mEXECUTEONLY	= mEXECUTEONLY;
    ctx->mEXECUTEREAD	= mEXECUTEREAD;
    ctx->mEXETYPE	= mEXETYPE;
    ctx->mFIXED	= mFIXED;
    ctx->mFUNCTIONS	= mFUNCTIONS;
    ctx->mIMPORTS	= mIMPORTS;
    ctx->mIMPURE	= mIMPURE;
    ctx->mINCLUDE	= mINCLUDE;
    ctx->mINITINSTANCE	= mINITINSTANCE;
    ctx->mIOPL	= mIOPL;
    ctx->mLOADONCALL	= mLOADONCALL;
    ctx->mLONGNAMES	= mLONGNAMES;
    ctx->mMOVABLE	= mMOVABLE;
    ctx->mMOVEABLE	= mMOVEABLE;
    ctx->mMULTIPLE	= mMULTIPLE;
    ctx->mNEWFILES	= mNEWFILES;
    ctx->mNODATA	= mNODATA;
    ctx->mNOIOPL	= mNOIOPL;
    ctx->mNONCONFORMING	= mNONCONFORMING;
    ctx->mNONDISCARDABLE	= mNONDISCARDABLE;
    ctx->mNONE	= mNONE;
    ctx->mNONSHARED	= mNONSHARED;
    ctx->mNOTWINDOWCOMPAT	= mNOTWINDOWCOMPAT;
    ctx->mOBJECTS	= mOBJECTS;
    ctx->mOLD	= mOLD;
    ctx->mPRELOAD	= mPRELOAD;
    ctx->mPROTMODE	= mPROTMODE;
    ctx->mPURE	= mPURE;
    ctx->mREADONLY	= mREADONLY;
    ctx->mREADWRITE	= mREADWRITE;
    ctx->mREALMODE	= mREALMODE;
    ctx->mRESIDENT	= mRESIDENT;
    ctx->mRESIDENTNAME	= mRESIDENTNAME;
    ctx->mSINGLE	= mSINGLE;
    ctx->mWINDOWAPI	= mWINDOWAPI;
    ctx->mWINDOWCOMPAT	= mWINDOWCOMPAT;
    ctx->mWINDOWS	= mWINDOWS;
    ctx->mT__56	= mT__56;
    ctx->mT__57	= mT__57;
    ctx->mT__58	= mT__58;
    ctx->mT__59	= mT__59;
    ctx->mT__60	= mT__60;
    ctx->mT__61	= mT__61;
    ctx->mT__62	= mT__62;
    ctx->mT__63	= mT__63;
    ctx->mT__64	= mT__64;
    ctx->mT__65	= mT__65;
    ctx->mT__66	= mT__66;
    ctx->mT__67	= mT__67;
    ctx->mT__68	= mT__68;
    ctx->mT__69	= mT__69;
    ctx->mT__70	= mT__70;
    ctx->mT__71	= mT__71;
    ctx->mT__72	= mT__72;
    ctx->mT__73	= mT__73;
    ctx->mT__74	= mT__74;
    ctx->mT__75	= mT__75;
    ctx->mT__76	= mT__76;
    ctx->mT__77	= mT__77;
    ctx->mT__78	= mT__78;
    ctx->mT__79	= mT__79;
    ctx->mT__80	= mT__80;
    ctx->mCOMMENT	= mCOMMENT;
    ctx->mSTRING	= mSTRING;
    ctx->mHEX	= mHEX;
    ctx->mINT	= mINT;
    ctx->mSYMBOL	= mSYMBOL;
    ctx->mWSTOKEN	= mWSTOKEN;
    ctx->mWHITESPACE	= mWHITESPACE;
    ctx->mTokens	= mTokens;
    
    /** When the nextToken() call is made to this lexer's pANTLR3_TOKEN_SOURCE
     *  it will call mTokens() in this generated code, and will pass it the ctx
     * pointer of this lexer, not the context of the base lexer, so store that now.
     */
    ctx->pLexer->ctx	    = ctx;
    
    /**Install the token matching function
     */
    ctx->pLexer->mTokens = (void (*) (void *))(mTokens);
    
    ctx->getGrammarFileName	= getGrammarFileName;
    ctx->free		= EEDGrammarLexerFree;

    
    


    /* Return the newly built lexer to the caller
     */
    return  ctx;
}

/* =========================================================================
 * DFA tables for the lexer
 */
/** Static dfa state tables for Cyclic dfa:
 *    1:1: Tokens : ( APPLOADER | CODE | CONFORMING | DESCRIPTION | DEV386 | DISCARDABLE | DYNAMIC | EXECUTE_ONLY | EXECUTEONLY | EXECUTEREAD | EXETYPE | FIXED | FUNCTIONS | IMPORTS | IMPURE | INCLUDE | INITINSTANCE | IOPL | LOADONCALL | LONGNAMES | MOVABLE | MOVEABLE | MULTIPLE | NEWFILES | NODATA | NOIOPL | NONCONFORMING | NONDISCARDABLE | NONE | NONSHARED | NOTWINDOWCOMPAT | OBJECTS | OLD | PRELOAD | PROTMODE | PURE | READONLY | READWRITE | REALMODE | RESIDENT | RESIDENTNAME | SINGLE | WINDOWAPI | WINDOWCOMPAT | WINDOWS | T__56 | T__57 | T__58 | T__59 | T__60 | T__61 | T__62 | T__63 | T__64 | T__65 | T__66 | T__67 | T__68 | T__69 | T__70 | T__71 | T__72 | T__73 | T__74 | T__75 | T__76 | T__77 | T__78 | T__79 | T__80 | COMMENT | STRING | HEX | INT | SYMBOL | WHITESPACE );
 */
static const ANTLR3_INT32 dfa9_eot[443] =
    {
	-1, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, -1, 32, -1, 
	32, -1, 68, -1, -1, 32, -1, -1, -1, -1, 71, 71, 70, 32, -1, -1, 32, 70, 
	32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 
	32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, -1, 32, -1, -1, 
	32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 
	32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 153, 32, 32, 32, 32, 32, 32, 32, 
	32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 173, 32, 32, 32, 32, 32, 179, 
	32, 32, 32, 32, 32, 32, 32, 32, 32, 189, 32, 32, 32, 32, 32, 32, 32, 32, 
	32, 32, 32, 201, 32, 32, 32, 205, 32, -1, 32, 32, 32, 210, 213, 32, 32, 
	32, 32, 218, 32, 32, 32, 32, 32, 224, 32, 32, 32, -1, 32, 32, 32, 32, 32, 
	-1, 32, 32, 32, 236, 32, 32, 32, 32, 32, -1, 32, 32, 32, 32, 32, 32, 32, 
	32, 32, 32, 32, -1, 32, 32, 32, -1, 32, 32, 32, 32, -1, 32, 32, -1, 32, 
	32, 32, 32, -1, 32, 32, 32, 32, 270, -1, 32, 32, 32, 32, 32, 276, 32, 32, 
	32, 32, 32, -1, 32, 32, 284, 32, 32, 32, 32, 32, 32, 32, 32, 32, 294, 295, 
	32, 32, 32, 299, 32, 32, 32, 32, 32, 32, 32, 32, 32, 309, 32, 32, 32, 313, 
	32, -1, 32, 32, 32, 32, 32, -1, 32, 323, 327, 328, 329, 32, 331, -1, 332, 
	32, 32, 32, 336, 337, 32, 32, 32, -1, -1, 32, 32, 32, -1, 32, 345, 346, 
	32, 348, 32, 32, 32, 32, -1, 32, 32, 32, -1, 32, 32, 358, 359, 32, 32, 
	32, 32, 32, -1, -1, 32, 32, -1, -1, -1, 32, -1, -1, 32, 32, 32, -1, -1, 
	371, 372, 373, 32, 32, 32, 32, -1, -1, 378, -1, 379, 32, 381, 383, 32, 
	385, 386, 32, 32, -1, -1, 389, 390, 32, 32, 32, 32, 32, 396, 32, 32, 399, 
	-1, -1, -1, 32, 32, 402, 32, -1, -1, 404, -1, 32, -1, 406, -1, -1, 407, 
	32, -1, -1, 409, 32, 32, 32, 32, -1, 32, 415, -1, 32, 32, -1, 32, -1, 32, 
	-1, -1, 32, -1, 421, 422, 423, 424, 32, -1, 32, 32, 32, 32, 32, -1, -1, 
	-1, -1, 431, 32, 32, 32, 435, 436, -1, 437, 32, 32, -1, -1, -1, 440, 32, 
	-1, 442, -1
    };
static const ANTLR3_INT32 dfa9_eof[443] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa9_min[443] =
    {
	9, 48, 48, 48, 48, 48, 77, 73, 79, 65, 66, 82, 69, 69, 73, -1, 48, -1, 
	69, -1, 36, -1, -1, 69, -1, -1, -1, -1, 48, 48, 36, 48, -1, -1, 80, 36, 
	48, 68, 48, 83, 78, 48, 69, 88, 78, 80, 67, 80, 65, 66, 86, 76, 87, 68, 
	77, 74, 68, 69, 82, 65, 78, 65, 67, 65, 78, 73, 48, 82, -1, 65, -1, -1, 
	76, 69, 70, 67, 51, 67, 65, 65, 67, 79, 69, 67, 79, 76, 84, 76, 68, 71, 
	82, 65, 84, 70, 65, 79, 65, 87, 69, 69, 36, 76, 84, 86, 69, 68, 73, 71, 
	67, 66, 84, 77, 82, 68, 84, 69, 83, 80, 79, 36, 79, 82, 56, 65, 77, 36, 
	85, 89, 82, 68, 84, 82, 82, 85, 73, 36, 79, 78, 65, 66, 65, 73, 73, 84, 
	80, 79, 73, 36, 72, 77, 73, 36, 67, -1, 79, 77, 65, 36, 36, 77, 68, 76, 
	75, 36, 73, 69, 69, 79, 69, 36, 73, 83, 65, -1, 82, 73, 54, 82, 73, -1, 
	84, 80, 84, 36, 73, 84, 69, 68, 78, -1, 78, 65, 82, 76, 66, 80, 76, 65, 
	76, 78, 83, -1, 65, 69, 78, -1, 84, 65, 79, 84, -1, 78, 82, -1, 79, 69, 
	69, 83, -1, 79, 78, 68, 87, 36, -1, 79, 73, 68, 77, 80, 36, 68, 67, 69, 
	69, 83, -1, 79, 83, 36, 69, 83, 67, 77, 89, 69, 76, 76, 69, 36, 36, 70, 
	67, 82, 36, 68, 83, 68, 68, 69, 76, 73, 68, 78, 36, 73, 78, 84, 36, 65, 
	-1, 78, 90, 69, 73, 84, -1, 65, 36, 36, 36, 36, 78, 36, -1, 36, 84, 65, 
	69, 36, 36, 69, 69, 83, -1, -1, 79, 65, 69, -1, 79, 36, 36, 69, 36, 89, 
	84, 69, 84, -1, 90, 83, 83, -1, 80, 79, 36, 36, 69, 82, 78, 73, 66, -1, 
	-1, 78, 69, -1, -1, -1, 83, -1, -1, 65, 76, 83, -1, -1, 36, 36, 36, 82, 
	82, 68, 87, -1, -1, 36, -1, 36, 69, 36, 36, 69, 36, 36, 73, 77, -1, -1, 
	36, 36, 71, 79, 76, 76, 65, 36, 78, 76, 36, -1, -1, -1, 77, 68, 36, 67, 
	-1, -1, 36, -1, 65, -1, 36, -1, -1, 36, 80, -1, -1, 36, 78, 69, 89, 68, 
	-1, 67, 36, -1, 73, 65, -1, 79, -1, 77, -1, -1, 65, -1, 36, 36, 36, 36, 
	69, -1, 78, 66, 77, 69, 84, -1, -1, -1, -1, 36, 71, 76, 80, 36, 36, -1, 
	36, 69, 65, -1, -1, -1, 36, 84, -1, 36, -1
    };
static const ANTLR3_INT32 dfa9_max[443] =
    {
	122, 104, 104, 104, 104, 104, 79, 79, 85, 79, 76, 85, 69, 84, 82, -1, 
	104, -1, 69, -1, 122, -1, -1, 69, -1, -1, -1, -1, 120, 104, 122, 104, -1, 
	-1, 80, 122, 104, 78, 104, 83, 78, 104, 80, 88, 78, 80, 73, 80, 78, 66, 
	86, 76, 87, 84, 77, 74, 68, 79, 82, 83, 78, 85, 71, 65, 78, 73, 104, 82, 
	-1, 65, -1, -1, 76, 69, 70, 67, 51, 67, 65, 65, 84, 79, 69, 67, 85, 76, 
	84, 76, 68, 71, 82, 69, 84, 70, 65, 79, 83, 87, 69, 69, 122, 76, 84, 86, 
	69, 76, 73, 71, 67, 66, 84, 77, 82, 68, 84, 69, 83, 80, 79, 122, 79, 82, 
	56, 65, 77, 122, 85, 89, 82, 68, 84, 82, 82, 85, 73, 122, 79, 78, 65, 66, 
	65, 73, 73, 84, 80, 79, 73, 122, 72, 77, 73, 122, 67, -1, 79, 77, 65, 122, 
	122, 77, 68, 76, 75, 122, 73, 69, 69, 79, 69, 122, 73, 83, 65, -1, 82, 
	73, 54, 82, 73, -1, 84, 80, 84, 122, 73, 84, 69, 68, 78, -1, 78, 65, 82, 
	76, 66, 80, 76, 65, 76, 78, 83, -1, 65, 69, 78, -1, 84, 65, 79, 84, -1, 
	78, 82, -1, 79, 69, 69, 83, -1, 79, 78, 68, 87, 122, -1, 79, 73, 68, 77, 
	80, 122, 68, 67, 69, 69, 83, -1, 79, 83, 122, 69, 83, 67, 77, 89, 69, 76, 
	76, 69, 122, 122, 70, 67, 82, 122, 68, 83, 68, 68, 69, 76, 73, 68, 78, 
	122, 73, 78, 84, 122, 83, -1, 78, 90, 69, 73, 84, -1, 65, 122, 122, 122, 
	122, 78, 122, -1, 122, 84, 65, 69, 122, 122, 69, 69, 83, -1, -1, 79, 65, 
	69, -1, 79, 122, 122, 69, 122, 89, 84, 69, 84, -1, 90, 83, 83, -1, 80, 
	79, 122, 122, 69, 82, 78, 73, 66, -1, -1, 78, 69, -1, -1, -1, 83, -1, -1, 
	65, 76, 83, -1, -1, 122, 122, 122, 82, 82, 68, 87, -1, -1, 122, -1, 122, 
	69, 122, 122, 69, 122, 122, 73, 77, -1, -1, 122, 122, 71, 79, 76, 76, 65, 
	122, 78, 76, 122, -1, -1, -1, 77, 68, 122, 67, -1, -1, 122, -1, 65, -1, 
	122, -1, -1, 122, 80, -1, -1, 122, 78, 69, 89, 68, -1, 67, 122, -1, 73, 
	65, -1, 79, -1, 77, -1, -1, 65, -1, 122, 122, 122, 122, 69, -1, 78, 66, 
	77, 69, 84, -1, -1, -1, -1, 122, 71, 76, 80, 122, 122, -1, 122, 69, 65, 
	-1, -1, -1, 122, 84, -1, 122, -1
    };
static const ANTLR3_INT32 dfa9_accept[443] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 48, -1, 50, 
	-1, 52, -1, 58, 59, -1, 69, 70, 71, 72, -1, -1, -1, -1, 75, 76, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 54, -1, 73, 74, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 33, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, -1, -1, 57, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 18, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 29, -1, -1, -1, 46, -1, -1, -1, -1, 36, -1, -1, 65, -1, -1, 
	-1, -1, 62, -1, -1, -1, -1, -1, 49, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 12, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	66, -1, -1, -1, -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, 15, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, 25, 26, -1, -1, -1, 55, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 42, -1, -1, -1, 68, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 
	8, -1, -1, 67, 11, 53, -1, 14, 16, -1, -1, -1, 47, 21, -1, -1, -1, -1, 
	-1, -1, -1, 32, 34, -1, 56, -1, -1, -1, -1, -1, -1, -1, -1, -1, 45, 51, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 22, 23, 24, -1, -1, -1, -1, 
	35, 37, -1, 39, -1, 40, -1, 63, 64, -1, -1, 60, 1, -1, -1, -1, -1, -1, 
	13, -1, -1, 20, -1, -1, 30, -1, 38, -1, 61, 43, -1, 3, -1, -1, -1, -1, 
	-1, 19, -1, -1, -1, -1, -1, 4, 6, 9, 10, -1, -1, -1, -1, -1, -1, 17, -1, 
	-1, -1, 41, 44, 27, -1, -1, 28, -1, 31
    };
static const ANTLR3_INT32 dfa9_special[443] =
    {	
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa9_T_empty	    NULL

static const ANTLR3_INT32 dfa9_T0[] =
    {
	176
    };static const ANTLR3_INT32 dfa9_T1[] =
    {
	230
    };static const ANTLR3_INT32 dfa9_T2[] =
    {
	59
    };static const ANTLR3_INT32 dfa9_T3[] =
    {
	77
    };static const ANTLR3_INT32 dfa9_T4[] =
    {
	410
    };static const ANTLR3_INT32 dfa9_T5[] =
    {
	32, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 32, 32, 32, 32, 32, 32, 
	32, 32, 32, 32, -1, -1, -1, -1, -1, 32, 32, 32, 32, 32, 32, 32, 32, 32, 
	32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 
	32, -1, -1, -1, -1, 32, -1, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 
	32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32
    };static const ANTLR3_INT32 dfa9_T6[] =
    {
	122
    };static const ANTLR3_INT32 dfa9_T7[] =
    {
	78
    };static const ANTLR3_INT32 dfa9_T8[] =
    {
	178
    };static const ANTLR3_INT32 dfa9_T9[] =
    {
	124
    };static const ANTLR3_INT32 dfa9_T10[] =
    {
	177
    };static const ANTLR3_INT32 dfa9_T11[] =
    {
	123
    };static const ANTLR3_INT32 dfa9_T12[] =
    {
	277
    };static const ANTLR3_INT32 dfa9_T13[] =
    {
	231
    };static const ANTLR3_INT32 dfa9_T14[] =
    {
	364
    };static const ANTLR3_INT32 dfa9_T15[] =
    {
	322
    };static const ANTLR3_INT32 dfa9_T16[] =
    {
	411
    };static const ANTLR3_INT32 dfa9_T17[] =
    {
	393
    };static const ANTLR3_INT32 dfa9_T18[] =
    {
	64, -1, -1, -1, -1, -1, -1, -1, -1, 65
    };static const ANTLR3_INT32 dfa9_T19[] =
    {
	228
    };static const ANTLR3_INT32 dfa9_T20[] =
    {
	274
    };static const ANTLR3_INT32 dfa9_T21[] =
    {
	120
    };static const ANTLR3_INT32 dfa9_T22[] =
    {
	174
    };static const ANTLR3_INT32 dfa9_T23[] =
    {
	119
    };static const ANTLR3_INT32 dfa9_T24[] =
    {
	229
    };static const ANTLR3_INT32 dfa9_T25[] =
    {
	175
    };static const ANTLR3_INT32 dfa9_T26[] =
    {
	121
    };static const ANTLR3_INT32 dfa9_T27[] =
    {
	392
    };static const ANTLR3_INT32 dfa9_T28[] =
    {
	363
    };static const ANTLR3_INT32 dfa9_T29[] =
    {
	321
    };static const ANTLR3_INT32 dfa9_T30[] =
    {
	275
    };static const ANTLR3_INT32 dfa9_T31[] =
    {
	391
    };static const ANTLR3_INT32 dfa9_T32[] =
    {
	362
    };static const ANTLR3_INT32 dfa9_T33[] =
    {
	320
    };static const ANTLR3_INT32 dfa9_T34[] =
    {
	413
    };static const ANTLR3_INT32 dfa9_T35[] =
    {
	366
    };static const ANTLR3_INT32 dfa9_T36[] =
    {
	395
    };static const ANTLR3_INT32 dfa9_T37[] =
    {
	129
    };static const ANTLR3_INT32 dfa9_T38[] =
    {
	82
    };static const ANTLR3_INT32 dfa9_T39[] =
    {
	183
    };static const ANTLR3_INT32 dfa9_T40[] =
    {
	36, 36, 36, 36, 36, 36, 36, 36, 36, 36, -1, -1, -1, -1, -1, -1, -1, 36, 
	36, 36, 36, 36, 36, -1, -1, -1, -1, -1, -1, -1, -1, -1, 34, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 36, 36, 36, 36, 36, 
	36, -1, 35
    };static const ANTLR3_INT32 dfa9_T41[] =
    {
	234
    };static const ANTLR3_INT32 dfa9_T42[] =
    {
	181
    };static const ANTLR3_INT32 dfa9_T43[] =
    {
	280
    };static const ANTLR3_INT32 dfa9_T44[] =
    {
	160
    };static const ANTLR3_INT32 dfa9_T45[] =
    {
	232
    };static const ANTLR3_INT32 dfa9_T46[] =
    {
	278
    };static const ANTLR3_INT32 dfa9_T47[] =
    {
	412
    };static const ANTLR3_INT32 dfa9_T48[] =
    {
	263
    };static const ANTLR3_INT32 dfa9_T49[] =
    {
	394
    };static const ANTLR3_INT32 dfa9_T50[] =
    {
	215
    };static const ANTLR3_INT32 dfa9_T51[] =
    {
	365
    };static const ANTLR3_INT32 dfa9_T52[] =
    {
	352
    };static const ANTLR3_INT32 dfa9_T53[] =
    {
	308
    };static const ANTLR3_INT32 dfa9_T54[] =
    {
	54, -1, -1, -1, 52, -1, -1, -1, -1, -1, -1, -1, -1, -1, 53
    };static const ANTLR3_INT32 dfa9_T55[] =
    {
	80, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 81
    };static const ANTLR3_INT32 dfa9_T56[] =
    {
	32, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 32, 32, 32, 32, 32, 32, 
	32, 32, 32, 32, -1, -1, -1, -1, -1, 32, 32, 32, 32, 32, 32, 32, 32, 32, 
	32, 32, 32, 32, 32, 32, 32, 211, 32, 32, 32, 32, 32, 32, 32, 212, 32, 32, 
	32, -1, -1, -1, -1, 32, -1, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 
	32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32
    };static const ANTLR3_INT32 dfa9_T57[] =
    {
	29, 29, 29, 29, 29, 29, 29, 29, 29, 29, -1, -1, -1, -1, -1, -1, -1, 70, 
	70, 70, 70, 70, 70, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 70, 70, 70, 70, 70, 
	70, -1, 70, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	70
    };static const ANTLR3_INT32 dfa9_T58[] =
    {
	158, -1, -1, -1, -1, -1, -1, -1, 159
    };static const ANTLR3_INT32 dfa9_T59[] =
    {
	67
    };static const ANTLR3_INT32 dfa9_T60[] =
    {
	45, 46, 47
    };static const ANTLR3_INT32 dfa9_T61[] =
    {
	273
    };static const ANTLR3_INT32 dfa9_T62[] =
    {
	319
    };static const ANTLR3_INT32 dfa9_T63[] =
    {
	361
    };static const ANTLR3_INT32 dfa9_T64[] =
    {
	72
    };static const ANTLR3_INT32 dfa9_T65[] =
    {
	118
    };static const ANTLR3_INT32 dfa9_T66[] =
    {
	172
    };static const ANTLR3_INT32 dfa9_T67[] =
    {
	227
    };static const ANTLR3_INT32 dfa9_T68[] =
    {
	32, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 32, 32, 32, 32, 32, 32, 
	32, 32, 32, 32, -1, -1, -1, -1, -1, 32, 32, 32, 32, 32, 32, 32, 32, 32, 
	32, 32, 32, 32, 32, 32, 382, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 
	32, -1, -1, -1, -1, 32, -1, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 
	32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32
    };static const ANTLR3_INT32 dfa9_T69[] =
    {
	29, 29, 29, 29, 29, 29, 29, 29, 29, 29, -1, -1, -1, -1, -1, -1, -1, 70, 
	70, 70, 70, 70, 70, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 70, 70, 70, 70, 70, 
	70, -1, 70
    };static const ANTLR3_INT32 dfa9_T70[] =
    {
	36, 36, 36, 36, 36, 36, 36, 36, 36, 36, -1, -1, -1, -1, -1, -1, -1, 36, 
	36, 36, 36, 36, 36, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 36, 36, 36, 36, 36, 
	36, -1, 35
    };static const ANTLR3_INT32 dfa9_T71[] =
    {
	36, 36, 36, 36, 36, 36, 36, 36, 36, 36, -1, -1, -1, -1, -1, -1, -1, 36, 
	36, 36, 36, 36, 36, -1, -1, -1, -1, -1, -1, -1, -1, 37, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 36, 36, 36, 36, 36, 
	36, -1, 35
    };static const ANTLR3_INT32 dfa9_T72[] =
    {
	105, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	106
    };static const ANTLR3_INT32 dfa9_T73[] =
    {
	62, -1, -1, 63, 60, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 61
    };static const ANTLR3_INT32 dfa9_T74[] =
    {
	69
    };static const ANTLR3_INT32 dfa9_T75[] =
    {
	149, -1, 145, 146, 147, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 148
    };static const ANTLR3_INT32 dfa9_T76[] =
    {
	268
    };static const ANTLR3_INT32 dfa9_T77[] =
    {
	221
    };static const ANTLR3_INT32 dfa9_T78[] =
    {
	166
    };static const ANTLR3_INT32 dfa9_T79[] =
    {
	112
    };static const ANTLR3_INT32 dfa9_T80[] =
    {
	223
    };static const ANTLR3_INT32 dfa9_T81[] =
    {
	168
    };static const ANTLR3_INT32 dfa9_T82[] =
    {
	114
    };static const ANTLR3_INT32 dfa9_T83[] =
    {
	355
    };static const ANTLR3_INT32 dfa9_T84[] =
    {
	312
    };static const ANTLR3_INT32 dfa9_T85[] =
    {
	169
    };static const ANTLR3_INT32 dfa9_T86[] =
    {
	289
    };static const ANTLR3_INT32 dfa9_T87[] =
    {
	317
    };static const ANTLR3_INT32 dfa9_T88[] =
    {
	271
    };static const ANTLR3_INT32 dfa9_T89[] =
    {
	225
    };static const ANTLR3_INT32 dfa9_T90[] =
    {
	170
    };static const ANTLR3_INT32 dfa9_T91[] =
    {
	116
    };static const ANTLR3_INT32 dfa9_T92[] =
    {
	113
    };static const ANTLR3_INT32 dfa9_T93[] =
    {
	128
    };static const ANTLR3_INT32 dfa9_T94[] =
    {
	182
    };static const ANTLR3_INT32 dfa9_T95[] =
    {
	235
    };static const ANTLR3_INT32 dfa9_T96[] =
    {
	269
    };static const ANTLR3_INT32 dfa9_T97[] =
    {
	281
    };static const ANTLR3_INT32 dfa9_T98[] =
    {
	167
    };static const ANTLR3_INT32 dfa9_T99[] =
    {
	222
    };static const ANTLR3_INT32 dfa9_T100[] =
    {
	259
    };static const ANTLR3_INT32 dfa9_T101[] =
    {
	209
    };static const ANTLR3_INT32 dfa9_T102[] =
    {
	101, -1, -1, -1, 103, -1, -1, -1, -1, -1, 102
    };static const ANTLR3_INT32 dfa9_T103[] =
    {
	304
    };static const ANTLR3_INT32 dfa9_T104[] =
    {
	314, -1, 315, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 316
    };static const ANTLR3_INT32 dfa9_T105[] =
    {
	156
    };static const ANTLR3_INT32 dfa9_T106[] =
    {
	88, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 89
    };static const ANTLR3_INT32 dfa9_T107[] =
    {
	254
    };static const ANTLR3_INT32 dfa9_T108[] =
    {
	55, -1, -1, -1, -1, -1, -1, -1, -1, -1, 56
    };static const ANTLR3_INT32 dfa9_T109[] =
    {
	203
    };static const ANTLR3_INT32 dfa9_T110[] =
    {
	125
    };static const ANTLR3_INT32 dfa9_T111[] =
    {
	360
    };static const ANTLR3_INT32 dfa9_T112[] =
    {
	162
    };static const ANTLR3_INT32 dfa9_T113[] =
    {
	36, 36, 36, 36, 36, 36, 36, 36, 36, 36, -1, -1, -1, -1, -1, -1, -1, 36, 
	36, 36, 36, 36, 36, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 75, 
	-1, -1, 76, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 36, 36, 36, 36, 36, 
	36, -1, 35
    };static const ANTLR3_INT32 dfa9_T114[] =
    {
	117
    };static const ANTLR3_INT32 dfa9_T115[] =
    {
	318
    };static const ANTLR3_INT32 dfa9_T116[] =
    {
	272
    };static const ANTLR3_INT32 dfa9_T117[] =
    {
	226
    };static const ANTLR3_INT32 dfa9_T118[] =
    {
	171
    };static const ANTLR3_INT32 dfa9_T119[] =
    {
	91
    };static const ANTLR3_INT32 dfa9_T120[] =
    {
	163
    };static const ANTLR3_INT32 dfa9_T121[] =
    {
	139, -1, -1, -1, 140
    };static const ANTLR3_INT32 dfa9_T122[] =
    {
	217
    };static const ANTLR3_INT32 dfa9_T123[] =
    {
	265
    };static const ANTLR3_INT32 dfa9_T124[] =
    {
	126, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 127
    };static const ANTLR3_INT32 dfa9_T125[] =
    {
	310
    };static const ANTLR3_INT32 dfa9_T126[] =
    {
	353
    };static const ANTLR3_INT32 dfa9_T127[] =
    {
	384
    };static const ANTLR3_INT32 dfa9_T128[] =
    {
	165
    };static const ANTLR3_INT32 dfa9_T129[] =
    {
	267
    };static const ANTLR3_INT32 dfa9_T130[] =
    {
	220
    };static const ANTLR3_INT32 dfa9_T131[] =
    {
	219
    };static const ANTLR3_INT32 dfa9_T132[] =
    {
	164
    };static const ANTLR3_INT32 dfa9_T133[] =
    {
	311
    };static const ANTLR3_INT32 dfa9_T134[] =
    {
	266
    };static const ANTLR3_INT32 dfa9_T135[] =
    {
	354
    };static const ANTLR3_INT32 dfa9_T136[] =
    {
	157
    };static const ANTLR3_INT32 dfa9_T137[] =
    {
	104
    };static const ANTLR3_INT32 dfa9_T138[] =
    {
	305
    };static const ANTLR3_INT32 dfa9_T139[] =
    {
	260
    };static const ANTLR3_INT32 dfa9_T140[] =
    {
	349
    };static const ANTLR3_INT32 dfa9_T141[] =
    {
	380
    };static const ANTLR3_INT32 dfa9_T142[] =
    {
	306
    };static const ANTLR3_INT32 dfa9_T143[] =
    {
	350
    };static const ANTLR3_INT32 dfa9_T144[] =
    {
	261
    };static const ANTLR3_INT32 dfa9_T145[] =
    {
	262
    };static const ANTLR3_INT32 dfa9_T146[] =
    {
	214
    };static const ANTLR3_INT32 dfa9_T147[] =
    {
	351
    };static const ANTLR3_INT32 dfa9_T148[] =
    {
	307
    };static const ANTLR3_INT32 dfa9_T149[] =
    {
	94, -1, -1, -1, -1, 95, -1, -1, -1, -1, 96, -1, -1, -1, -1, -1, 97
    };static const ANTLR3_INT32 dfa9_T150[] =
    {
	405
    };static const ANTLR3_INT32 dfa9_T151[] =
    {
	429
    };static const ANTLR3_INT32 dfa9_T152[] =
    {
	419
    };static const ANTLR3_INT32 dfa9_T153[] =
    {
	50, -1, -1, -1, -1, -1, 51
    };static const ANTLR3_INT32 dfa9_T154[] =
    {
	107
    };static const ANTLR3_INT32 dfa9_T155[] =
    {
	33, 33, -1, 33, 33, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 33, -1, 27, 21, 32, -1, -1, -1, -1, -1, -1, -1, 15, 
	-1, 19, 25, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 22, 26, -1, 17, -1, 
	32, 20, 1, 16, 2, 3, 4, 5, 32, 23, 6, 32, 32, 7, 8, 9, 10, 11, 32, 12, 
	13, 32, 32, 18, 14, 32, 32, 32, -1, 24, -1, -1, 32, -1, 31, 31, 31, 31, 
	31, 31, 32, 30, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 
	32, 32, 32, 32
    };static const ANTLR3_INT32 dfa9_T156[] =
    {
	264
    };static const ANTLR3_INT32 dfa9_T157[] =
    {
	216
    };static const ANTLR3_INT32 dfa9_T158[] =
    {
	161
    };static const ANTLR3_INT32 dfa9_T159[] =
    {
	131, -1, -1, -1, -1, -1, 132
    };static const ANTLR3_INT32 dfa9_T160[] =
    {
	279
    };static const ANTLR3_INT32 dfa9_T161[] =
    {
	84
    };static const ANTLR3_INT32 dfa9_T162[] =
    {
	387
    };static const ANTLR3_INT32 dfa9_T163[] =
    {
	233
    };static const ANTLR3_INT32 dfa9_T164[] =
    {
	356
    };static const ANTLR3_INT32 dfa9_T165[] =
    {
	180
    };static const ANTLR3_INT32 dfa9_T166[] =
    {
	110, -1, -1, -1, 111
    };static const ANTLR3_INT32 dfa9_T167[] =
    {
	357
    };static const ANTLR3_INT32 dfa9_T168[] =
    {
	408
    };static const ANTLR3_INT32 dfa9_T169[] =
    {
	388
    };static const ANTLR3_INT32 dfa9_T170[] =
    {
	430
    };static const ANTLR3_INT32 dfa9_T171[] =
    {
	420
    };static const ANTLR3_INT32 dfa9_T172[] =
    {
	98
    };static const ANTLR3_INT32 dfa9_T173[] =
    {
	151
    };static const ANTLR3_INT32 dfa9_T174[] =
    {
	85, -1, -1, -1, -1, -1, 86
    };static const ANTLR3_INT32 dfa9_T175[] =
    {
	90
    };static const ANTLR3_INT32 dfa9_T176[] =
    {
	138
    };static const ANTLR3_INT32 dfa9_T177[] =
    {
	192
    };static const ANTLR3_INT32 dfa9_T178[] =
    {
	244
    };static const ANTLR3_INT32 dfa9_T179[] =
    {
	296
    };static const ANTLR3_INT32 dfa9_T180[] =
    {
	251
    };static const ANTLR3_INT32 dfa9_T181[] =
    {
	374
    };static const ANTLR3_INT32 dfa9_T182[] =
    {
	341
    };static const ANTLR3_INT32 dfa9_T183[] =
    {
	199
    };static const ANTLR3_INT32 dfa9_T184[] =
    {
	144
    };static const ANTLR3_INT32 dfa9_T185[] =
    {
	250
    };static const ANTLR3_INT32 dfa9_T186[] =
    {
	198
    };static const ANTLR3_INT32 dfa9_T187[] =
    {
	143
    };static const ANTLR3_INT32 dfa9_T188[] =
    {
	197
    };static const ANTLR3_INT32 dfa9_T189[] =
    {
	249
    };static const ANTLR3_INT32 dfa9_T190[] =
    {
	293
    };static const ANTLR3_INT32 dfa9_T191[] =
    {
	340
    };static const ANTLR3_INT32 dfa9_T192[] =
    {
	36, 36, 36, 36, 36, 36, 36, 36, 36, 36, -1, -1, -1, -1, -1, -1, -1, 36, 
	36, 36, 36, 36, 36, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	79, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 36, 36, 36, 36, 36, 
	36, -1, 35
    };static const ANTLR3_INT32 dfa9_T193[] =
    {
	438
    };static const ANTLR3_INT32 dfa9_T194[] =
    {
	433
    };static const ANTLR3_INT32 dfa9_T195[] =
    {
	427
    };static const ANTLR3_INT32 dfa9_T196[] =
    {
	417
    };static const ANTLR3_INT32 dfa9_T197[] =
    {
	401
    };static const ANTLR3_INT32 dfa9_T198[] =
    {
	342
    };static const ANTLR3_INT32 dfa9_T199[] =
    {
	375
    };static const ANTLR3_INT32 dfa9_T200[] =
    {
	252
    };static const ANTLR3_INT32 dfa9_T201[] =
    {
	297
    };static const ANTLR3_INT32 dfa9_T202[] =
    {
	200
    };static const ANTLR3_INT32 dfa9_T203[] =
    {
	426
    };static const ANTLR3_INT32 dfa9_T204[] =
    {
	432
    };static const ANTLR3_INT32 dfa9_T205[] =
    {
	108, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 109
    };static const ANTLR3_INT32 dfa9_T206[] =
    {
	400
    };static const ANTLR3_INT32 dfa9_T207[] =
    {
	416
    };static const ANTLR3_INT32 dfa9_T208[] =
    {
	441
    };static const ANTLR3_INT32 dfa9_T209[] =
    {
	439
    };static const ANTLR3_INT32 dfa9_T210[] =
    {
	99
    };static const ANTLR3_INT32 dfa9_T211[] =
    {
	300
    };static const ANTLR3_INT32 dfa9_T212[] =
    {
	255
    };static const ANTLR3_INT32 dfa9_T213[] =
    {
	377
    };static const ANTLR3_INT32 dfa9_T214[] =
    {
	344
    };static const ANTLR3_INT32 dfa9_T215[] =
    {
	418
    };static const ANTLR3_INT32 dfa9_T216[] =
    {
	403
    };static const ANTLR3_INT32 dfa9_T217[] =
    {
	434
    };static const ANTLR3_INT32 dfa9_T218[] =
    {
	428
    };static const ANTLR3_INT32 dfa9_T219[] =
    {
	150
    };static const ANTLR3_INT32 dfa9_T220[] =
    {
	204
    };static const ANTLR3_INT32 dfa9_T221[] =
    {
	202
    };static const ANTLR3_INT32 dfa9_T222[] =
    {
	253
    };static const ANTLR3_INT32 dfa9_T223[] =
    {
	298
    };static const ANTLR3_INT32 dfa9_T224[] =
    {
	36, 36, 36, 36, 36, 36, 36, 36, 36, 36, -1, -1, -1, -1, -1, -1, -1, 41, 
	36, 36, 36, 38, 36, -1, -1, 39, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 40, -1, -1, -1, -1, -1, -1, -1, 36, 36, 36, 36, 36, 
	36, -1, 35
    };static const ANTLR3_INT32 dfa9_T225[] =
    {
	343
    };static const ANTLR3_INT32 dfa9_T226[] =
    {
	376
    };static const ANTLR3_INT32 dfa9_T227[] =
    {
	208
    };static const ANTLR3_INT32 dfa9_T228[] =
    {
	155
    };static const ANTLR3_INT32 dfa9_T229[] =
    {
	347
    };static const ANTLR3_INT32 dfa9_T230[] =
    {
	303
    };static const ANTLR3_INT32 dfa9_T231[] =
    {
	258
    };static const ANTLR3_INT32 dfa9_T232[] =
    {
	302
    };static const ANTLR3_INT32 dfa9_T233[] =
    {
	257
    };static const ANTLR3_INT32 dfa9_T234[] =
    {
	207
    };static const ANTLR3_INT32 dfa9_T235[] =
    {
	154
    };static const ANTLR3_INT32 dfa9_T236[] =
    {
	100
    };static const ANTLR3_INT32 dfa9_T237[] =
    {
	36, 36, 36, 36, 36, 36, 36, 36, 36, 36, -1, -1, -1, -1, -1, -1, -1, 36, 
	36, 36, 36, 36, 36, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 115, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 36, 36, 36, 36, 36, 
	36, -1, 35
    };static const ANTLR3_INT32 dfa9_T238[] =
    {
	256
    };static const ANTLR3_INT32 dfa9_T239[] =
    {
	301
    };static const ANTLR3_INT32 dfa9_T240[] =
    {
	152
    };static const ANTLR3_INT32 dfa9_T241[] =
    {
	206
    };static const ANTLR3_INT32 dfa9_T242[] =
    {
	283
    };static const ANTLR3_INT32 dfa9_T243[] =
    {
	185
    };static const ANTLR3_INT32 dfa9_T244[] =
    {
	238
    };static const ANTLR3_INT32 dfa9_T245[] =
    {
	186
    };static const ANTLR3_INT32 dfa9_T246[] =
    {
	239
    };static const ANTLR3_INT32 dfa9_T247[] =
    {
	49, -1, -1, -1, -1, -1, 48
    };static const ANTLR3_INT32 dfa9_T248[] =
    {
	130
    };static const ANTLR3_INT32 dfa9_T249[] =
    {
	83
    };static const ANTLR3_INT32 dfa9_T250[] =
    {
	237
    };static const ANTLR3_INT32 dfa9_T251[] =
    {
	184
    };static const ANTLR3_INT32 dfa9_T252[] =
    {
	57, -1, -1, 58
    };static const ANTLR3_INT32 dfa9_T253[] =
    {
	36, 36, 36, 36, 36, 36, 36, 36, 36, 36, -1, -1, -1, -1, -1, -1, -1, 66, 
	36, 36, 36, 36, 36, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 36, 36, 36, 36, 36, 
	36, -1, 35
    };static const ANTLR3_INT32 dfa9_T254[] =
    {
	330
    };static const ANTLR3_INT32 dfa9_T255[] =
    {
	282
    };static const ANTLR3_INT32 dfa9_T256[] =
    {
	367
    };static const ANTLR3_INT32 dfa9_T257[] =
    {
	425
    };static const ANTLR3_INT32 dfa9_T258[] =
    {
	73, -1, -1, -1, -1, -1, -1, -1, -1, -1, 74
    };static const ANTLR3_INT32 dfa9_T259[] =
    {
	36, 36, 36, 36, 36, 36, 36, 36, 36, 36, -1, -1, -1, -1, -1, -1, -1, 36, 
	36, 36, 36, 36, 36, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 42, -1, -1, -1, -1, -1, -1, -1, -1, 36, 36, 36, 36, 36, 
	36, -1, 35
    };static const ANTLR3_INT32 dfa9_T260[] =
    {
	397
    };static const ANTLR3_INT32 dfa9_T261[] =
    {
	414
    };static const ANTLR3_INT32 dfa9_T262[] =
    {
	333
    };static const ANTLR3_INT32 dfa9_T263[] =
    {
	368
    };static const ANTLR3_INT32 dfa9_T264[] =
    {
	241
    };static const ANTLR3_INT32 dfa9_T265[] =
    {
	286
    };static const ANTLR3_INT32 dfa9_T266[] =
    {
	87
    };static const ANTLR3_INT32 dfa9_T267[] =
    {
	135
    };static const ANTLR3_INT32 dfa9_T268[] =
    {
	285
    };static const ANTLR3_INT32 dfa9_T269[] =
    {
	240
    };static const ANTLR3_INT32 dfa9_T270[] =
    {
	187
    };static const ANTLR3_INT32 dfa9_T271[] =
    {
	133
    };static const ANTLR3_INT32 dfa9_T272[] =
    {
	188
    };static const ANTLR3_INT32 dfa9_T273[] =
    {
	134
    };static const ANTLR3_INT32 dfa9_T274[] =
    {
	137
    };static const ANTLR3_INT32 dfa9_T275[] =
    {
	191
    };static const ANTLR3_INT32 dfa9_T276[] =
    {
	243
    };static const ANTLR3_INT32 dfa9_T277[] =
    {
	288
    };static const ANTLR3_INT32 dfa9_T278[] =
    {
	335
    };static const ANTLR3_INT32 dfa9_T279[] =
    {
	370
    };static const ANTLR3_INT32 dfa9_T280[] =
    {
	193
    };static const ANTLR3_INT32 dfa9_T281[] =
    {
	245
    };static const ANTLR3_INT32 dfa9_T282[] =
    {
	190
    };static const ANTLR3_INT32 dfa9_T283[] =
    {
	136
    };static const ANTLR3_INT32 dfa9_T284[] =
    {
	287
    };static const ANTLR3_INT32 dfa9_T285[] =
    {
	242
    };static const ANTLR3_INT32 dfa9_T286[] =
    {
	369
    };static const ANTLR3_INT32 dfa9_T287[] =
    {
	334
    };static const ANTLR3_INT32 dfa9_T288[] =
    {
	398
    };static const ANTLR3_INT32 dfa9_T289[] =
    {
	141
    };static const ANTLR3_INT32 dfa9_T290[] =
    {
	195
    };static const ANTLR3_INT32 dfa9_T291[] =
    {
	92
    };static const ANTLR3_INT32 dfa9_T292[] =
    {
	339
    };static const ANTLR3_INT32 dfa9_T293[] =
    {
	247
    };static const ANTLR3_INT32 dfa9_T294[] =
    {
	292
    };static const ANTLR3_INT32 dfa9_T295[] =
    {
	196
    };static const ANTLR3_INT32 dfa9_T296[] =
    {
	248
    };static const ANTLR3_INT32 dfa9_T297[] =
    {
	93
    };static const ANTLR3_INT32 dfa9_T298[] =
    {
	142
    };static const ANTLR3_INT32 dfa9_T299[] =
    {
	32, -1, -1, -1, -1, -1, -1, -1, -1, 324, -1, -1, 32, 32, 32, 32, 32, 32, 
	32, 32, 32, 32, -1, -1, -1, -1, -1, 32, 32, 32, 32, 32, 32, 32, 32, 32, 
	32, 32, 32, 32, 32, 32, 32, 325, 32, 32, 326, 32, 32, 32, 32, 32, 32, 32, 
	32, -1, -1, -1, -1, 32, -1, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 
	32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32
    };static const ANTLR3_INT32 dfa9_T300[] =
    {
	290
    };static const ANTLR3_INT32 dfa9_T301[] =
    {
	338
    };static const ANTLR3_INT32 dfa9_T302[] =
    {
	36, 36, 36, 36, 36, 36, 36, 36, 36, 36, -1, -1, -1, -1, -1, -1, -1, 36, 
	36, 36, 36, 36, 36, -1, -1, 43, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 44, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 36, 36, 36, 36, 36, 
	36, -1, 35
    };static const ANTLR3_INT32 dfa9_T303[] =
    {
	291
    };static const ANTLR3_INT32 dfa9_T304[] =
    {
	246
    };static const ANTLR3_INT32 dfa9_T305[] =
    {
	194
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa9_transitions[] =
{
    dfa9_T155, dfa9_T40, dfa9_T71, dfa9_T224, dfa9_T259, dfa9_T302, dfa9_T60, 
    dfa9_T247, dfa9_T153, dfa9_T54, dfa9_T108, dfa9_T252, dfa9_T2, dfa9_T73, 
    dfa9_T18, dfa9_T_empty, dfa9_T253, dfa9_T_empty, dfa9_T59, dfa9_T_empty, 
    dfa9_T5, dfa9_T_empty, dfa9_T_empty, dfa9_T74, dfa9_T_empty, dfa9_T_empty, 
    dfa9_T_empty, dfa9_T_empty, dfa9_T57, dfa9_T69, dfa9_T5, dfa9_T70, dfa9_T_empty, 
    dfa9_T_empty, dfa9_T64, dfa9_T5, dfa9_T70, dfa9_T258, dfa9_T113, dfa9_T3, 
    dfa9_T7, dfa9_T192, dfa9_T55, dfa9_T38, dfa9_T249, dfa9_T161, dfa9_T174, 
    dfa9_T266, dfa9_T106, dfa9_T175, dfa9_T119, dfa9_T291, dfa9_T297, dfa9_T149, 
    dfa9_T172, dfa9_T210, dfa9_T236, dfa9_T102, dfa9_T137, dfa9_T72, dfa9_T154, 
    dfa9_T205, dfa9_T166, dfa9_T79, dfa9_T92, dfa9_T82, dfa9_T237, dfa9_T91, 
    dfa9_T_empty, dfa9_T114, dfa9_T_empty, dfa9_T_empty, dfa9_T65, dfa9_T23, 
    dfa9_T21, dfa9_T26, dfa9_T6, dfa9_T11, dfa9_T9, dfa9_T110, dfa9_T124, 
    dfa9_T93, dfa9_T37, dfa9_T248, dfa9_T159, dfa9_T271, dfa9_T273, dfa9_T267, 
    dfa9_T283, dfa9_T274, dfa9_T176, dfa9_T121, dfa9_T289, dfa9_T298, dfa9_T187, 
    dfa9_T184, dfa9_T75, dfa9_T219, dfa9_T173, dfa9_T240, dfa9_T5, dfa9_T235, 
    dfa9_T228, dfa9_T105, dfa9_T136, dfa9_T58, dfa9_T44, dfa9_T158, dfa9_T112, 
    dfa9_T120, dfa9_T132, dfa9_T128, dfa9_T78, dfa9_T98, dfa9_T81, dfa9_T85, 
    dfa9_T90, dfa9_T118, dfa9_T66, dfa9_T5, dfa9_T22, dfa9_T25, dfa9_T0, 
    dfa9_T10, dfa9_T8, dfa9_T5, dfa9_T165, dfa9_T42, dfa9_T94, dfa9_T39, 
    dfa9_T251, dfa9_T243, dfa9_T245, dfa9_T270, dfa9_T272, dfa9_T5, dfa9_T282, 
    dfa9_T275, dfa9_T177, dfa9_T280, dfa9_T305, dfa9_T290, dfa9_T295, dfa9_T188, 
    dfa9_T186, dfa9_T183, dfa9_T202, dfa9_T5, dfa9_T221, dfa9_T109, dfa9_T220, 
    dfa9_T5, dfa9_T241, dfa9_T_empty, dfa9_T234, dfa9_T227, dfa9_T101, dfa9_T5, 
    dfa9_T56, dfa9_T146, dfa9_T50, dfa9_T157, dfa9_T122, dfa9_T5, dfa9_T131, 
    dfa9_T130, dfa9_T77, dfa9_T99, dfa9_T80, dfa9_T5, dfa9_T89, dfa9_T117, 
    dfa9_T67, dfa9_T_empty, dfa9_T19, dfa9_T24, dfa9_T1, dfa9_T13, dfa9_T45, 
    dfa9_T_empty, dfa9_T163, dfa9_T41, dfa9_T95, dfa9_T5, dfa9_T250, dfa9_T244, 
    dfa9_T246, dfa9_T269, dfa9_T264, dfa9_T_empty, dfa9_T285, dfa9_T276, 
    dfa9_T178, dfa9_T281, dfa9_T304, dfa9_T293, dfa9_T296, dfa9_T189, dfa9_T185, 
    dfa9_T180, dfa9_T200, dfa9_T_empty, dfa9_T222, dfa9_T107, dfa9_T212, 
    dfa9_T_empty, dfa9_T238, dfa9_T233, dfa9_T231, dfa9_T100, dfa9_T_empty, 
    dfa9_T139, dfa9_T144, dfa9_T_empty, dfa9_T145, dfa9_T48, dfa9_T156, 
    dfa9_T123, dfa9_T_empty, dfa9_T134, dfa9_T129, dfa9_T76, dfa9_T96, dfa9_T5, 
    dfa9_T_empty, dfa9_T88, dfa9_T116, dfa9_T61, dfa9_T20, dfa9_T30, dfa9_T5, 
    dfa9_T12, dfa9_T46, dfa9_T160, dfa9_T43, dfa9_T97, dfa9_T_empty, dfa9_T255, 
    dfa9_T242, dfa9_T5, dfa9_T268, dfa9_T265, dfa9_T284, dfa9_T277, dfa9_T86, 
    dfa9_T300, dfa9_T303, dfa9_T294, dfa9_T190, dfa9_T5, dfa9_T5, dfa9_T179, 
    dfa9_T201, dfa9_T223, dfa9_T5, dfa9_T211, dfa9_T239, dfa9_T232, dfa9_T230, 
    dfa9_T103, dfa9_T138, dfa9_T142, dfa9_T148, dfa9_T53, dfa9_T5, dfa9_T125, 
    dfa9_T133, dfa9_T84, dfa9_T5, dfa9_T104, dfa9_T_empty, dfa9_T87, dfa9_T115, 
    dfa9_T62, dfa9_T33, dfa9_T29, dfa9_T_empty, dfa9_T15, dfa9_T5, dfa9_T299, 
    dfa9_T5, dfa9_T5, dfa9_T254, dfa9_T5, dfa9_T_empty, dfa9_T5, dfa9_T262, 
    dfa9_T287, dfa9_T278, dfa9_T5, dfa9_T5, dfa9_T301, dfa9_T292, dfa9_T191, 
    dfa9_T_empty, dfa9_T_empty, dfa9_T182, dfa9_T198, dfa9_T225, dfa9_T_empty, 
    dfa9_T214, dfa9_T5, dfa9_T5, dfa9_T229, dfa9_T5, dfa9_T140, dfa9_T143, 
    dfa9_T147, dfa9_T52, dfa9_T_empty, dfa9_T126, dfa9_T135, dfa9_T83, dfa9_T_empty, 
    dfa9_T164, dfa9_T167, dfa9_T5, dfa9_T5, dfa9_T111, dfa9_T63, dfa9_T32, 
    dfa9_T28, dfa9_T14, dfa9_T_empty, dfa9_T_empty, dfa9_T51, dfa9_T35, 
    dfa9_T_empty, dfa9_T_empty, dfa9_T_empty, dfa9_T256, dfa9_T_empty, dfa9_T_empty, 
    dfa9_T263, dfa9_T286, dfa9_T279, dfa9_T_empty, dfa9_T_empty, dfa9_T5, 
    dfa9_T5, dfa9_T5, dfa9_T181, dfa9_T199, dfa9_T226, dfa9_T213, dfa9_T_empty, 
    dfa9_T_empty, dfa9_T5, dfa9_T_empty, dfa9_T5, dfa9_T141, dfa9_T5, dfa9_T68, 
    dfa9_T127, dfa9_T5, dfa9_T5, dfa9_T162, dfa9_T169, dfa9_T_empty, dfa9_T_empty, 
    dfa9_T5, dfa9_T5, dfa9_T31, dfa9_T27, dfa9_T17, dfa9_T49, dfa9_T36, 
    dfa9_T5, dfa9_T260, dfa9_T288, dfa9_T5, dfa9_T_empty, dfa9_T_empty, 
    dfa9_T_empty, dfa9_T206, dfa9_T197, dfa9_T5, dfa9_T216, dfa9_T_empty, 
    dfa9_T_empty, dfa9_T5, dfa9_T_empty, dfa9_T150, dfa9_T_empty, dfa9_T5, 
    dfa9_T_empty, dfa9_T_empty, dfa9_T5, dfa9_T168, dfa9_T_empty, dfa9_T_empty, 
    dfa9_T5, dfa9_T4, dfa9_T16, dfa9_T47, dfa9_T34, dfa9_T_empty, dfa9_T261, 
    dfa9_T5, dfa9_T_empty, dfa9_T207, dfa9_T196, dfa9_T_empty, dfa9_T215, 
    dfa9_T_empty, dfa9_T152, dfa9_T_empty, dfa9_T_empty, dfa9_T171, dfa9_T_empty, 
    dfa9_T5, dfa9_T5, dfa9_T5, dfa9_T5, dfa9_T257, dfa9_T_empty, dfa9_T203, 
    dfa9_T195, dfa9_T218, dfa9_T151, dfa9_T170, dfa9_T_empty, dfa9_T_empty, 
    dfa9_T_empty, dfa9_T_empty, dfa9_T5, dfa9_T204, dfa9_T194, dfa9_T217, 
    dfa9_T5, dfa9_T5, dfa9_T_empty, dfa9_T5, dfa9_T193, dfa9_T209, dfa9_T_empty, 
    dfa9_T_empty, dfa9_T_empty, dfa9_T5, dfa9_T208, dfa9_T_empty, dfa9_T5, 
    dfa9_T_empty	
};


/* Declare tracking structure for Cyclic DFA 9
 */
static
ANTLR3_CYCLIC_DFA cdfa9
    =	{
	    9,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"1:1: Tokens : ( APPLOADER | CODE | CONFORMING | DESCRIPTION | DEV386 | DISCARDABLE | DYNAMIC | EXECUTE_ONLY | EXECUTEONLY | EXECUTEREAD | EXETYPE | FIXED | FUNCTIONS | IMPORTS | IMPURE | INCLUDE | INITINSTANCE | IOPL | LOADONCALL | LONGNAMES | MOVABLE | MOVEABLE | MULTIPLE | NEWFILES | NODATA | NOIOPL | NONCONFORMING | NONDISCARDABLE | NONE | NONSHARED | NOTWINDOWCOMPAT | OBJECTS | OLD | PRELOAD | PROTMODE | PURE | READONLY | READWRITE | REALMODE | RESIDENT | RESIDENTNAME | SINGLE | WINDOWAPI | WINDOWCOMPAT | WINDOWS | T__56 | T__57 | T__58 | T__59 | T__60 | T__61 | T__62 | T__63 | T__64 | T__65 | T__66 | T__67 | T__68 | T__69 | T__70 | T__71 | T__72 | T__73 | T__74 | T__75 | T__76 | T__77 | T__78 | T__79 | T__80 | COMMENT | STRING | HEX | INT | SYMBOL | WHITESPACE );",	
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa9_eot,	    /* EOT table			    */
	    dfa9_eof,	    /* EOF table			    */
	    dfa9_min,	    /* Minimum tokens for each state    */
	    dfa9_max,	    /* Maximum tokens for each state    */
	    dfa9_accept,	/* Accept table			    */
	    dfa9_special,	/* Special transition states	    */
	    dfa9_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 9
 * ---------------------
 */ 
/* =========================================================================
 * End of DFA tables for the lexer
 */ 

/* =========================================================================
 * Functions to match the lexer grammar defined tokens from the input stream
 */

//   Comes from: 11:11: ( 'APPLOADER' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start APPLOADER
 *
 * Looks to match the characters the constitute the token APPLOADER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mAPPLOADER(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = APPLOADER;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:11:11: ( 'APPLOADER' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:11:13: 'APPLOADER'
    {
        MATCHS(lit_1); 
        if  (HASEXCEPTION())
        {
            goto ruleAPPLOADEREx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleAPPLOADEREx; /* Prevent compiler warnings */
    ruleAPPLOADEREx: ;

}
// $ANTLR end APPLOADER

//   Comes from: 12:6: ( 'CODE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CODE
 *
 * Looks to match the characters the constitute the token CODE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mCODE(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = CODE;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:12:6: ( 'CODE' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:12:8: 'CODE'
    {
        MATCHS(lit_2); 
        if  (HASEXCEPTION())
        {
            goto ruleCODEEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleCODEEx; /* Prevent compiler warnings */
    ruleCODEEx: ;

}
// $ANTLR end CODE

//   Comes from: 13:12: ( 'CONFORMING' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CONFORMING
 *
 * Looks to match the characters the constitute the token CONFORMING
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mCONFORMING(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = CONFORMING;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:13:12: ( 'CONFORMING' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:13:14: 'CONFORMING'
    {
        MATCHS(lit_3); 
        if  (HASEXCEPTION())
        {
            goto ruleCONFORMINGEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleCONFORMINGEx; /* Prevent compiler warnings */
    ruleCONFORMINGEx: ;

}
// $ANTLR end CONFORMING

//   Comes from: 14:13: ( 'DESCRIPTION' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DESCRIPTION
 *
 * Looks to match the characters the constitute the token DESCRIPTION
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDESCRIPTION(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = DESCRIPTION;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:14:13: ( 'DESCRIPTION' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:14:15: 'DESCRIPTION'
    {
        MATCHS(lit_4); 
        if  (HASEXCEPTION())
        {
            goto ruleDESCRIPTIONEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleDESCRIPTIONEx; /* Prevent compiler warnings */
    ruleDESCRIPTIONEx: ;

}
// $ANTLR end DESCRIPTION

//   Comes from: 15:8: ( 'DEV386' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DEV386
 *
 * Looks to match the characters the constitute the token DEV386
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDEV386(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = DEV386;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:15:8: ( 'DEV386' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:15:10: 'DEV386'
    {
        MATCHS(lit_5); 
        if  (HASEXCEPTION())
        {
            goto ruleDEV386Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleDEV386Ex; /* Prevent compiler warnings */
    ruleDEV386Ex: ;

}
// $ANTLR end DEV386

//   Comes from: 16:13: ( 'DISCARDABLE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DISCARDABLE
 *
 * Looks to match the characters the constitute the token DISCARDABLE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDISCARDABLE(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = DISCARDABLE;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:16:13: ( 'DISCARDABLE' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:16:15: 'DISCARDABLE'
    {
        MATCHS(lit_6); 
        if  (HASEXCEPTION())
        {
            goto ruleDISCARDABLEEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleDISCARDABLEEx; /* Prevent compiler warnings */
    ruleDISCARDABLEEx: ;

}
// $ANTLR end DISCARDABLE

//   Comes from: 17:9: ( 'DYNAMIC' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DYNAMIC
 *
 * Looks to match the characters the constitute the token DYNAMIC
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDYNAMIC(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = DYNAMIC;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:17:9: ( 'DYNAMIC' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:17:11: 'DYNAMIC'
    {
        MATCHS(lit_7); 
        if  (HASEXCEPTION())
        {
            goto ruleDYNAMICEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleDYNAMICEx; /* Prevent compiler warnings */
    ruleDYNAMICEx: ;

}
// $ANTLR end DYNAMIC

//   Comes from: 18:14: ( 'EXECUTE-ONLY' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EXECUTE_ONLY
 *
 * Looks to match the characters the constitute the token EXECUTE_ONLY
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mEXECUTE_ONLY(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = EXECUTE_ONLY;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:18:14: ( 'EXECUTE-ONLY' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:18:16: 'EXECUTE-ONLY'
    {
        MATCHS(lit_8); 
        if  (HASEXCEPTION())
        {
            goto ruleEXECUTE_ONLYEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleEXECUTE_ONLYEx; /* Prevent compiler warnings */
    ruleEXECUTE_ONLYEx: ;

}
// $ANTLR end EXECUTE_ONLY

//   Comes from: 19:13: ( 'EXECUTEONLY' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EXECUTEONLY
 *
 * Looks to match the characters the constitute the token EXECUTEONLY
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mEXECUTEONLY(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = EXECUTEONLY;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:19:13: ( 'EXECUTEONLY' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:19:15: 'EXECUTEONLY'
    {
        MATCHS(lit_9); 
        if  (HASEXCEPTION())
        {
            goto ruleEXECUTEONLYEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleEXECUTEONLYEx; /* Prevent compiler warnings */
    ruleEXECUTEONLYEx: ;

}
// $ANTLR end EXECUTEONLY

//   Comes from: 20:13: ( 'EXECUTEREAD' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EXECUTEREAD
 *
 * Looks to match the characters the constitute the token EXECUTEREAD
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mEXECUTEREAD(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = EXECUTEREAD;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:20:13: ( 'EXECUTEREAD' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:20:15: 'EXECUTEREAD'
    {
        MATCHS(lit_10); 
        if  (HASEXCEPTION())
        {
            goto ruleEXECUTEREADEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleEXECUTEREADEx; /* Prevent compiler warnings */
    ruleEXECUTEREADEx: ;

}
// $ANTLR end EXECUTEREAD

//   Comes from: 21:9: ( 'EXETYPE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EXETYPE
 *
 * Looks to match the characters the constitute the token EXETYPE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mEXETYPE(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = EXETYPE;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:21:9: ( 'EXETYPE' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:21:11: 'EXETYPE'
    {
        MATCHS(lit_11); 
        if  (HASEXCEPTION())
        {
            goto ruleEXETYPEEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleEXETYPEEx; /* Prevent compiler warnings */
    ruleEXETYPEEx: ;

}
// $ANTLR end EXETYPE

//   Comes from: 22:7: ( 'FIXED' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FIXED
 *
 * Looks to match the characters the constitute the token FIXED
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mFIXED(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = FIXED;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:22:7: ( 'FIXED' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:22:9: 'FIXED'
    {
        MATCHS(lit_12); 
        if  (HASEXCEPTION())
        {
            goto ruleFIXEDEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleFIXEDEx; /* Prevent compiler warnings */
    ruleFIXEDEx: ;

}
// $ANTLR end FIXED

//   Comes from: 23:11: ( 'FUNCTIONS' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FUNCTIONS
 *
 * Looks to match the characters the constitute the token FUNCTIONS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mFUNCTIONS(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = FUNCTIONS;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:23:11: ( 'FUNCTIONS' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:23:13: 'FUNCTIONS'
    {
        MATCHS(lit_13); 
        if  (HASEXCEPTION())
        {
            goto ruleFUNCTIONSEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleFUNCTIONSEx; /* Prevent compiler warnings */
    ruleFUNCTIONSEx: ;

}
// $ANTLR end FUNCTIONS

//   Comes from: 24:9: ( 'IMPORTS' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start IMPORTS
 *
 * Looks to match the characters the constitute the token IMPORTS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mIMPORTS(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = IMPORTS;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:24:9: ( 'IMPORTS' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:24:11: 'IMPORTS'
    {
        MATCHS(lit_14); 
        if  (HASEXCEPTION())
        {
            goto ruleIMPORTSEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleIMPORTSEx; /* Prevent compiler warnings */
    ruleIMPORTSEx: ;

}
// $ANTLR end IMPORTS

//   Comes from: 25:8: ( 'IMPURE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start IMPURE
 *
 * Looks to match the characters the constitute the token IMPURE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mIMPURE(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = IMPURE;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:25:8: ( 'IMPURE' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:25:10: 'IMPURE'
    {
        MATCHS(lit_15); 
        if  (HASEXCEPTION())
        {
            goto ruleIMPUREEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleIMPUREEx; /* Prevent compiler warnings */
    ruleIMPUREEx: ;

}
// $ANTLR end IMPURE

//   Comes from: 26:9: ( 'INCLUDE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start INCLUDE
 *
 * Looks to match the characters the constitute the token INCLUDE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mINCLUDE(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = INCLUDE;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:26:9: ( 'INCLUDE' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:26:11: 'INCLUDE'
    {
        MATCHS(lit_16); 
        if  (HASEXCEPTION())
        {
            goto ruleINCLUDEEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleINCLUDEEx; /* Prevent compiler warnings */
    ruleINCLUDEEx: ;

}
// $ANTLR end INCLUDE

//   Comes from: 27:14: ( 'INITINSTANCE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start INITINSTANCE
 *
 * Looks to match the characters the constitute the token INITINSTANCE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mINITINSTANCE(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = INITINSTANCE;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:27:14: ( 'INITINSTANCE' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:27:16: 'INITINSTANCE'
    {
        MATCHS(lit_17); 
        if  (HASEXCEPTION())
        {
            goto ruleINITINSTANCEEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleINITINSTANCEEx; /* Prevent compiler warnings */
    ruleINITINSTANCEEx: ;

}
// $ANTLR end INITINSTANCE

//   Comes from: 28:6: ( 'IOPL' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start IOPL
 *
 * Looks to match the characters the constitute the token IOPL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mIOPL(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = IOPL;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:28:6: ( 'IOPL' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:28:8: 'IOPL'
    {
        MATCHS(lit_18); 
        if  (HASEXCEPTION())
        {
            goto ruleIOPLEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleIOPLEx; /* Prevent compiler warnings */
    ruleIOPLEx: ;

}
// $ANTLR end IOPL

//   Comes from: 29:12: ( 'LOADONCALL' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LOADONCALL
 *
 * Looks to match the characters the constitute the token LOADONCALL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mLOADONCALL(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = LOADONCALL;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:29:12: ( 'LOADONCALL' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:29:14: 'LOADONCALL'
    {
        MATCHS(lit_19); 
        if  (HASEXCEPTION())
        {
            goto ruleLOADONCALLEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleLOADONCALLEx; /* Prevent compiler warnings */
    ruleLOADONCALLEx: ;

}
// $ANTLR end LOADONCALL

//   Comes from: 30:11: ( 'LONGNAMES' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LONGNAMES
 *
 * Looks to match the characters the constitute the token LONGNAMES
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mLONGNAMES(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = LONGNAMES;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:30:11: ( 'LONGNAMES' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:30:13: 'LONGNAMES'
    {
        MATCHS(lit_20); 
        if  (HASEXCEPTION())
        {
            goto ruleLONGNAMESEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleLONGNAMESEx; /* Prevent compiler warnings */
    ruleLONGNAMESEx: ;

}
// $ANTLR end LONGNAMES

//   Comes from: 31:9: ( 'MOVABLE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start MOVABLE
 *
 * Looks to match the characters the constitute the token MOVABLE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mMOVABLE(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = MOVABLE;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:31:9: ( 'MOVABLE' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:31:11: 'MOVABLE'
    {
        MATCHS(lit_21); 
        if  (HASEXCEPTION())
        {
            goto ruleMOVABLEEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleMOVABLEEx; /* Prevent compiler warnings */
    ruleMOVABLEEx: ;

}
// $ANTLR end MOVABLE

//   Comes from: 32:10: ( 'MOVEABLE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start MOVEABLE
 *
 * Looks to match the characters the constitute the token MOVEABLE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mMOVEABLE(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = MOVEABLE;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:32:10: ( 'MOVEABLE' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:32:12: 'MOVEABLE'
    {
        MATCHS(lit_22); 
        if  (HASEXCEPTION())
        {
            goto ruleMOVEABLEEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleMOVEABLEEx; /* Prevent compiler warnings */
    ruleMOVEABLEEx: ;

}
// $ANTLR end MOVEABLE

//   Comes from: 33:10: ( 'MULTIPLE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start MULTIPLE
 *
 * Looks to match the characters the constitute the token MULTIPLE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mMULTIPLE(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = MULTIPLE;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:33:10: ( 'MULTIPLE' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:33:12: 'MULTIPLE'
    {
        MATCHS(lit_23); 
        if  (HASEXCEPTION())
        {
            goto ruleMULTIPLEEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleMULTIPLEEx; /* Prevent compiler warnings */
    ruleMULTIPLEEx: ;

}
// $ANTLR end MULTIPLE

//   Comes from: 34:10: ( 'NEWFILES' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NEWFILES
 *
 * Looks to match the characters the constitute the token NEWFILES
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mNEWFILES(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = NEWFILES;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:34:10: ( 'NEWFILES' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:34:12: 'NEWFILES'
    {
        MATCHS(lit_24); 
        if  (HASEXCEPTION())
        {
            goto ruleNEWFILESEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleNEWFILESEx; /* Prevent compiler warnings */
    ruleNEWFILESEx: ;

}
// $ANTLR end NEWFILES

//   Comes from: 35:8: ( 'NODATA' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NODATA
 *
 * Looks to match the characters the constitute the token NODATA
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mNODATA(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = NODATA;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:35:8: ( 'NODATA' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:35:10: 'NODATA'
    {
        MATCHS(lit_25); 
        if  (HASEXCEPTION())
        {
            goto ruleNODATAEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleNODATAEx; /* Prevent compiler warnings */
    ruleNODATAEx: ;

}
// $ANTLR end NODATA

//   Comes from: 36:8: ( 'NOIOPL' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NOIOPL
 *
 * Looks to match the characters the constitute the token NOIOPL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mNOIOPL(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = NOIOPL;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:36:8: ( 'NOIOPL' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:36:10: 'NOIOPL'
    {
        MATCHS(lit_26); 
        if  (HASEXCEPTION())
        {
            goto ruleNOIOPLEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleNOIOPLEx; /* Prevent compiler warnings */
    ruleNOIOPLEx: ;

}
// $ANTLR end NOIOPL

//   Comes from: 37:15: ( 'NONCONFORMING' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NONCONFORMING
 *
 * Looks to match the characters the constitute the token NONCONFORMING
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mNONCONFORMING(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = NONCONFORMING;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:37:15: ( 'NONCONFORMING' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:37:17: 'NONCONFORMING'
    {
        MATCHS(lit_27); 
        if  (HASEXCEPTION())
        {
            goto ruleNONCONFORMINGEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleNONCONFORMINGEx; /* Prevent compiler warnings */
    ruleNONCONFORMINGEx: ;

}
// $ANTLR end NONCONFORMING

//   Comes from: 38:16: ( 'NONDISCARDABLE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NONDISCARDABLE
 *
 * Looks to match the characters the constitute the token NONDISCARDABLE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mNONDISCARDABLE(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = NONDISCARDABLE;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:38:16: ( 'NONDISCARDABLE' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:38:18: 'NONDISCARDABLE'
    {
        MATCHS(lit_28); 
        if  (HASEXCEPTION())
        {
            goto ruleNONDISCARDABLEEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleNONDISCARDABLEEx; /* Prevent compiler warnings */
    ruleNONDISCARDABLEEx: ;

}
// $ANTLR end NONDISCARDABLE

//   Comes from: 39:6: ( 'NONE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NONE
 *
 * Looks to match the characters the constitute the token NONE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mNONE(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = NONE;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:39:6: ( 'NONE' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:39:8: 'NONE'
    {
        MATCHS(lit_29); 
        if  (HASEXCEPTION())
        {
            goto ruleNONEEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleNONEEx; /* Prevent compiler warnings */
    ruleNONEEx: ;

}
// $ANTLR end NONE

//   Comes from: 40:11: ( 'NONSHARED' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NONSHARED
 *
 * Looks to match the characters the constitute the token NONSHARED
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mNONSHARED(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = NONSHARED;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:40:11: ( 'NONSHARED' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:40:13: 'NONSHARED'
    {
        MATCHS(lit_30); 
        if  (HASEXCEPTION())
        {
            goto ruleNONSHAREDEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleNONSHAREDEx; /* Prevent compiler warnings */
    ruleNONSHAREDEx: ;

}
// $ANTLR end NONSHARED

//   Comes from: 41:17: ( 'NOTWINDOWCOMPAT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NOTWINDOWCOMPAT
 *
 * Looks to match the characters the constitute the token NOTWINDOWCOMPAT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mNOTWINDOWCOMPAT(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = NOTWINDOWCOMPAT;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:41:17: ( 'NOTWINDOWCOMPAT' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:41:19: 'NOTWINDOWCOMPAT'
    {
        MATCHS(lit_31); 
        if  (HASEXCEPTION())
        {
            goto ruleNOTWINDOWCOMPATEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleNOTWINDOWCOMPATEx; /* Prevent compiler warnings */
    ruleNOTWINDOWCOMPATEx: ;

}
// $ANTLR end NOTWINDOWCOMPAT

//   Comes from: 42:9: ( 'OBJECTS' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start OBJECTS
 *
 * Looks to match the characters the constitute the token OBJECTS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mOBJECTS(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = OBJECTS;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:42:9: ( 'OBJECTS' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:42:11: 'OBJECTS'
    {
        MATCHS(lit_32); 
        if  (HASEXCEPTION())
        {
            goto ruleOBJECTSEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleOBJECTSEx; /* Prevent compiler warnings */
    ruleOBJECTSEx: ;

}
// $ANTLR end OBJECTS

//   Comes from: 43:5: ( 'OLD' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start OLD
 *
 * Looks to match the characters the constitute the token OLD
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mOLD(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = OLD;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:43:5: ( 'OLD' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:43:7: 'OLD'
    {
        MATCHS(lit_33); 
        if  (HASEXCEPTION())
        {
            goto ruleOLDEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleOLDEx; /* Prevent compiler warnings */
    ruleOLDEx: ;

}
// $ANTLR end OLD

//   Comes from: 44:9: ( 'PRELOAD' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PRELOAD
 *
 * Looks to match the characters the constitute the token PRELOAD
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mPRELOAD(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = PRELOAD;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:44:9: ( 'PRELOAD' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:44:11: 'PRELOAD'
    {
        MATCHS(lit_34); 
        if  (HASEXCEPTION())
        {
            goto rulePRELOADEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto rulePRELOADEx; /* Prevent compiler warnings */
    rulePRELOADEx: ;

}
// $ANTLR end PRELOAD

//   Comes from: 45:10: ( 'PROTMODE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PROTMODE
 *
 * Looks to match the characters the constitute the token PROTMODE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mPROTMODE(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = PROTMODE;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:45:10: ( 'PROTMODE' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:45:12: 'PROTMODE'
    {
        MATCHS(lit_35); 
        if  (HASEXCEPTION())
        {
            goto rulePROTMODEEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto rulePROTMODEEx; /* Prevent compiler warnings */
    rulePROTMODEEx: ;

}
// $ANTLR end PROTMODE

//   Comes from: 46:6: ( 'PURE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PURE
 *
 * Looks to match the characters the constitute the token PURE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mPURE(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = PURE;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:46:6: ( 'PURE' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:46:8: 'PURE'
    {
        MATCHS(lit_36); 
        if  (HASEXCEPTION())
        {
            goto rulePUREEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto rulePUREEx; /* Prevent compiler warnings */
    rulePUREEx: ;

}
// $ANTLR end PURE

//   Comes from: 47:10: ( 'READONLY' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start READONLY
 *
 * Looks to match the characters the constitute the token READONLY
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mREADONLY(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = READONLY;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:47:10: ( 'READONLY' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:47:12: 'READONLY'
    {
        MATCHS(lit_37); 
        if  (HASEXCEPTION())
        {
            goto ruleREADONLYEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleREADONLYEx; /* Prevent compiler warnings */
    ruleREADONLYEx: ;

}
// $ANTLR end READONLY

//   Comes from: 48:11: ( 'READWRITE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start READWRITE
 *
 * Looks to match the characters the constitute the token READWRITE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mREADWRITE(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = READWRITE;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:48:11: ( 'READWRITE' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:48:13: 'READWRITE'
    {
        MATCHS(lit_38); 
        if  (HASEXCEPTION())
        {
            goto ruleREADWRITEEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleREADWRITEEx; /* Prevent compiler warnings */
    ruleREADWRITEEx: ;

}
// $ANTLR end READWRITE

//   Comes from: 49:10: ( 'REALMODE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start REALMODE
 *
 * Looks to match the characters the constitute the token REALMODE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mREALMODE(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = REALMODE;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:49:10: ( 'REALMODE' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:49:12: 'REALMODE'
    {
        MATCHS(lit_39); 
        if  (HASEXCEPTION())
        {
            goto ruleREALMODEEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleREALMODEEx; /* Prevent compiler warnings */
    ruleREALMODEEx: ;

}
// $ANTLR end REALMODE

//   Comes from: 50:10: ( 'RESIDENT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start RESIDENT
 *
 * Looks to match the characters the constitute the token RESIDENT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mRESIDENT(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = RESIDENT;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:50:10: ( 'RESIDENT' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:50:12: 'RESIDENT'
    {
        MATCHS(lit_40); 
        if  (HASEXCEPTION())
        {
            goto ruleRESIDENTEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleRESIDENTEx; /* Prevent compiler warnings */
    ruleRESIDENTEx: ;

}
// $ANTLR end RESIDENT

//   Comes from: 51:14: ( 'RESIDENTNAME' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start RESIDENTNAME
 *
 * Looks to match the characters the constitute the token RESIDENTNAME
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mRESIDENTNAME(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = RESIDENTNAME;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:51:14: ( 'RESIDENTNAME' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:51:16: 'RESIDENTNAME'
    {
        MATCHS(lit_41); 
        if  (HASEXCEPTION())
        {
            goto ruleRESIDENTNAMEEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleRESIDENTNAMEEx; /* Prevent compiler warnings */
    ruleRESIDENTNAMEEx: ;

}
// $ANTLR end RESIDENTNAME

//   Comes from: 52:8: ( 'SINGLE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SINGLE
 *
 * Looks to match the characters the constitute the token SINGLE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSINGLE(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SINGLE;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:52:8: ( 'SINGLE' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:52:10: 'SINGLE'
    {
        MATCHS(lit_42); 
        if  (HASEXCEPTION())
        {
            goto ruleSINGLEEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleSINGLEEx; /* Prevent compiler warnings */
    ruleSINGLEEx: ;

}
// $ANTLR end SINGLE

//   Comes from: 53:11: ( 'WINDOWAPI' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start WINDOWAPI
 *
 * Looks to match the characters the constitute the token WINDOWAPI
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mWINDOWAPI(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = WINDOWAPI;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:53:11: ( 'WINDOWAPI' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:53:13: 'WINDOWAPI'
    {
        MATCHS(lit_43); 
        if  (HASEXCEPTION())
        {
            goto ruleWINDOWAPIEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleWINDOWAPIEx; /* Prevent compiler warnings */
    ruleWINDOWAPIEx: ;

}
// $ANTLR end WINDOWAPI

//   Comes from: 54:14: ( 'WINDOWCOMPAT' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start WINDOWCOMPAT
 *
 * Looks to match the characters the constitute the token WINDOWCOMPAT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mWINDOWCOMPAT(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = WINDOWCOMPAT;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:54:14: ( 'WINDOWCOMPAT' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:54:16: 'WINDOWCOMPAT'
    {
        MATCHS(lit_44); 
        if  (HASEXCEPTION())
        {
            goto ruleWINDOWCOMPATEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleWINDOWCOMPATEx; /* Prevent compiler warnings */
    ruleWINDOWCOMPATEx: ;

}
// $ANTLR end WINDOWCOMPAT

//   Comes from: 55:9: ( 'WINDOWS' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start WINDOWS
 *
 * Looks to match the characters the constitute the token WINDOWS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mWINDOWS(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = WINDOWS;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:55:9: ( 'WINDOWS' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:55:11: 'WINDOWS'
    {
        MATCHS(lit_45); 
        if  (HASEXCEPTION())
        {
            goto ruleWINDOWSEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleWINDOWSEx; /* Prevent compiler warnings */
    ruleWINDOWSEx: ;

}
// $ANTLR end WINDOWS

//   Comes from: 56:7: ( 'NAME' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__56
 *
 * Looks to match the characters the constitute the token T__56
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__56(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__56;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:56:7: ( 'NAME' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:56:9: 'NAME'
    {
        MATCHS(lit_46); 
        if  (HASEXCEPTION())
        {
            goto ruleT__56Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__56Ex; /* Prevent compiler warnings */
    ruleT__56Ex: ;

}
// $ANTLR end T__56

//   Comes from: 57:7: ( 'LIBRARY' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__57
 *
 * Looks to match the characters the constitute the token T__57
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__57(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__57;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:57:7: ( 'LIBRARY' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:57:9: 'LIBRARY'
    {
        MATCHS(lit_47); 
        if  (HASEXCEPTION())
        {
            goto ruleT__57Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__57Ex; /* Prevent compiler warnings */
    ruleT__57Ex: ;

}
// $ANTLR end T__57

//   Comes from: 58:7: ( ',' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__58
 *
 * Looks to match the characters the constitute the token T__58
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__58(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__58;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:58:7: ( ',' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:58:9: ','
    {
        MATCHC(','); 
        if  (HASEXCEPTION())
        {
            goto ruleT__58Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__58Ex; /* Prevent compiler warnings */
    ruleT__58Ex: ;

}
// $ANTLR end T__58

//   Comes from: 59:7: ( 'BASE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__59
 *
 * Looks to match the characters the constitute the token T__59
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__59(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__59;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:59:7: ( 'BASE' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:59:9: 'BASE'
    {
        MATCHS(lit_48); 
        if  (HASEXCEPTION())
        {
            goto ruleT__59Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__59Ex; /* Prevent compiler warnings */
    ruleT__59Ex: ;

}
// $ANTLR end T__59

//   Comes from: 60:7: ( '=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__60
 *
 * Looks to match the characters the constitute the token T__60
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__60(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__60;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:60:7: ( '=' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:60:9: '='
    {
        MATCHC('='); 
        if  (HASEXCEPTION())
        {
            goto ruleT__60Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__60Ex; /* Prevent compiler warnings */
    ruleT__60Ex: ;

}
// $ANTLR end T__60

//   Comes from: 61:7: ( 'VERSION' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__61
 *
 * Looks to match the characters the constitute the token T__61
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__61(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__61;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:61:7: ( 'VERSION' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:61:9: 'VERSION'
    {
        MATCHS(lit_49); 
        if  (HASEXCEPTION())
        {
            goto ruleT__61Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__61Ex; /* Prevent compiler warnings */
    ruleT__61Ex: ;

}
// $ANTLR end T__61

//   Comes from: 62:7: ( '.' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__62
 *
 * Looks to match the characters the constitute the token T__62
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__62(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__62;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:62:7: ( '.' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:62:9: '.'
    {
        MATCHC('.'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__62Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__62Ex; /* Prevent compiler warnings */
    ruleT__62Ex: ;

}
// $ANTLR end T__62

//   Comes from: 63:7: ( 'EXPORTS' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__63
 *
 * Looks to match the characters the constitute the token T__63
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__63(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__63;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:63:7: ( 'EXPORTS' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:63:9: 'EXPORTS'
    {
        MATCHS(lit_50); 
        if  (HASEXCEPTION())
        {
            goto ruleT__63Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__63Ex; /* Prevent compiler warnings */
    ruleT__63Ex: ;

}
// $ANTLR end T__63

//   Comes from: 64:7: ( '@' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__64
 *
 * Looks to match the characters the constitute the token T__64
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__64(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__64;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:64:7: ( '@' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:64:9: '@'
    {
        MATCHC('@'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__64Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__64Ex; /* Prevent compiler warnings */
    ruleT__64Ex: ;

}
// $ANTLR end T__64

//   Comes from: 65:7: ( 'NONAME' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__65
 *
 * Looks to match the characters the constitute the token T__65
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__65(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__65;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:65:7: ( 'NONAME' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:65:9: 'NONAME'
    {
        MATCHS(lit_51); 
        if  (HASEXCEPTION())
        {
            goto ruleT__65Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__65Ex; /* Prevent compiler warnings */
    ruleT__65Ex: ;

}
// $ANTLR end T__65

//   Comes from: 66:7: ( 'PRIVATE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__66
 *
 * Looks to match the characters the constitute the token T__66
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__66(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__66;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:66:7: ( 'PRIVATE' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:66:9: 'PRIVATE'
    {
        MATCHS(lit_52); 
        if  (HASEXCEPTION())
        {
            goto ruleT__66Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__66Ex; /* Prevent compiler warnings */
    ruleT__66Ex: ;

}
// $ANTLR end T__66

//   Comes from: 67:7: ( 'DATA' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__67
 *
 * Looks to match the characters the constitute the token T__67
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__67(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__67;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:67:7: ( 'DATA' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:67:9: 'DATA'
    {
        MATCHS(lit_53); 
        if  (HASEXCEPTION())
        {
            goto ruleT__67Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__67Ex; /* Prevent compiler warnings */
    ruleT__67Ex: ;

}
// $ANTLR end T__67

//   Comes from: 68:7: ( '#' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__68
 *
 * Looks to match the characters the constitute the token T__68
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__68(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__68;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:68:7: ( '#' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:68:9: '#'
    {
        MATCHC('#'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__68Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__68Ex; /* Prevent compiler warnings */
    ruleT__68Ex: ;

}
// $ANTLR end T__68

//   Comes from: 69:7: ( ':' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__69
 *
 * Looks to match the characters the constitute the token T__69
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__69(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__69;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:69:7: ( ':' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:69:9: ':'
    {
        MATCHC(':'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__69Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__69Ex; /* Prevent compiler warnings */
    ruleT__69Ex: ;

}
// $ANTLR end T__69

//   Comes from: 70:7: ( 'HEAPSIZE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__70
 *
 * Looks to match the characters the constitute the token T__70
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__70(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__70;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:70:7: ( 'HEAPSIZE' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:70:9: 'HEAPSIZE'
    {
        MATCHS(lit_54); 
        if  (HASEXCEPTION())
        {
            goto ruleT__70Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__70Ex; /* Prevent compiler warnings */
    ruleT__70Ex: ;

}
// $ANTLR end T__70

//   Comes from: 71:7: ( 'STACKSIZE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__71
 *
 * Looks to match the characters the constitute the token T__71
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__71(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__71;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:71:7: ( 'STACKSIZE' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:71:9: 'STACKSIZE'
    {
        MATCHS(lit_55); 
        if  (HASEXCEPTION())
        {
            goto ruleT__71Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__71Ex; /* Prevent compiler warnings */
    ruleT__71Ex: ;

}
// $ANTLR end T__71

//   Comes from: 72:7: ( 'STUB' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__72
 *
 * Looks to match the characters the constitute the token T__72
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__72(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__72;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:72:7: ( 'STUB' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:72:9: 'STUB'
    {
        MATCHS(lit_56); 
        if  (HASEXCEPTION())
        {
            goto ruleT__72Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__72Ex; /* Prevent compiler warnings */
    ruleT__72Ex: ;

}
// $ANTLR end T__72

//   Comes from: 73:7: ( 'SECTIONS' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__73
 *
 * Looks to match the characters the constitute the token T__73
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__73(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__73;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:73:7: ( 'SECTIONS' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:73:9: 'SECTIONS'
    {
        MATCHS(lit_57); 
        if  (HASEXCEPTION())
        {
            goto ruleT__73Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__73Ex; /* Prevent compiler warnings */
    ruleT__73Ex: ;

}
// $ANTLR end T__73

//   Comes from: 74:7: ( 'SEGMENTS' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__74
 *
 * Looks to match the characters the constitute the token T__74
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__74(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__74;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:74:7: ( 'SEGMENTS' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:74:9: 'SEGMENTS'
    {
        MATCHS(lit_58); 
        if  (HASEXCEPTION())
        {
            goto ruleT__74Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__74Ex; /* Prevent compiler warnings */
    ruleT__74Ex: ;

}
// $ANTLR end T__74

//   Comes from: 75:7: ( 'READ' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__75
 *
 * Looks to match the characters the constitute the token T__75
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__75(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__75;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:75:7: ( 'READ' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:75:9: 'READ'
    {
        MATCHS(lit_59); 
        if  (HASEXCEPTION())
        {
            goto ruleT__75Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__75Ex; /* Prevent compiler warnings */
    ruleT__75Ex: ;

}
// $ANTLR end T__75

//   Comes from: 76:7: ( 'WRITE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__76
 *
 * Looks to match the characters the constitute the token T__76
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__76(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__76;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:76:7: ( 'WRITE' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:76:9: 'WRITE'
    {
        MATCHS(lit_60); 
        if  (HASEXCEPTION())
        {
            goto ruleT__76Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__76Ex; /* Prevent compiler warnings */
    ruleT__76Ex: ;

}
// $ANTLR end T__76

//   Comes from: 77:7: ( 'EXECUTE' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__77
 *
 * Looks to match the characters the constitute the token T__77
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__77(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__77;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:77:7: ( 'EXECUTE' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:77:9: 'EXECUTE'
    {
        MATCHS(lit_61); 
        if  (HASEXCEPTION())
        {
            goto ruleT__77Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__77Ex; /* Prevent compiler warnings */
    ruleT__77Ex: ;

}
// $ANTLR end T__77

//   Comes from: 78:7: ( 'SHARED' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__78
 *
 * Looks to match the characters the constitute the token T__78
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__78(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__78;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:78:7: ( 'SHARED' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:78:9: 'SHARED'
    {
        MATCHS(lit_62); 
        if  (HASEXCEPTION())
        {
            goto ruleT__78Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__78Ex; /* Prevent compiler warnings */
    ruleT__78Ex: ;

}
// $ANTLR end T__78

//   Comes from: 79:7: ( '\\\\' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__79
 *
 * Looks to match the characters the constitute the token T__79
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__79(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__79;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:79:7: ( '\\\\' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:79:9: '\\\\'
    {
        MATCHC('\\'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__79Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__79Ex; /* Prevent compiler warnings */
    ruleT__79Ex: ;

}
// $ANTLR end T__79

//   Comes from: 80:7: ( '/' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__80
 *
 * Looks to match the characters the constitute the token T__80
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__80(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__80;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:80:7: ( '/' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:80:9: '/'
    {
        MATCHC('/'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__80Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__80Ex; /* Prevent compiler warnings */
    ruleT__80Ex: ;

}
// $ANTLR end T__80

//   Comes from: 199:5: ( ';' (~ ( '\\n' | '\\r' ) )* ( '\\r' | '\\n' | EOF ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start COMMENT
 *
 * Looks to match the characters the constitute the token COMMENT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mCOMMENT(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = COMMENT;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:199:5: ( ';' (~ ( '\\n' | '\\r' ) )* ( '\\r' | '\\n' | EOF ) )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:199:9: ';' (~ ( '\\n' | '\\r' ) )* ( '\\r' | '\\n' | EOF )
    {
        MATCHC(';'); 
        if  (HASEXCEPTION())
        {
            goto ruleCOMMENTEx;
        }


        // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:199:13: (~ ( '\\n' | '\\r' ) )*

        for (;;)
        {
            int alt1=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA1_0 = LA(1);
                if ( (((LA1_0 >= 0x0000) && (LA1_0 <= '\t')) || ((LA1_0 >= 0x000B) && (LA1_0 <= '\f')) || ((LA1_0 >= 0x000E) && (LA1_0 <= 0xFFFF))) ) 
                {
                    alt1=1;
                }

            }
            switch (alt1) 
            {
        	case 1:
        	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:199:14: ~ ( '\\n' | '\\r' )
        	    {
        	        if ( ((LA(1) >= 0x0000) && (LA(1) <= '\t')) || ((LA(1) >= 0x000B) && (LA(1) <= '\f')) || ((LA(1) >= 0x000E) && (LA(1) <= 0xFFFF)) )
        	        {
        	            CONSUME();

        	        }
        	        else 
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();    goto ruleCOMMENTEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop1;	/* break out of the loop */
        	    break;
            }
        }
        loop1: ; /* Jump out to here if this rule does not match */


        // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:199:29: ( '\\r' | '\\n' | EOF )
        {
            int alt2=3;
            switch ( LA(1) ) 
            {
            case '\r':
            	{
            		alt2=1;
            	}
                break;
            case '\n':
            	{
            		alt2=2;
            	}
                break;

            default:
                alt2=3;}

            switch (alt2) 
            {
        	case 1:
        	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:199:30: '\\r'
        	    {
        	        MATCHC('\r'); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleCOMMENTEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:199:35: '\\n'
        	    {
        	        MATCHC('\n'); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleCOMMENTEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:199:40: EOF
        	    {
        	            MATCHC(ANTLR3_CHARSTREAM_EOF); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleCOMMENTEx;
        	            }


        	    }
        	    break;

            }
        }
        {
            LEXSTATE->channel=HIDDEN;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleCOMMENTEx; /* Prevent compiler warnings */
    ruleCOMMENTEx: ;

}
// $ANTLR end COMMENT

//   Comes from: 203:5: ( '\"' (~ ( '\"' | '\\n' | '\\r' ) )* '\"' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start STRING
 *
 * Looks to match the characters the constitute the token STRING
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSTRING(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = STRING;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:203:5: ( '\"' (~ ( '\"' | '\\n' | '\\r' ) )* '\"' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:203:8: '\"' (~ ( '\"' | '\\n' | '\\r' ) )* '\"'
    {
        MATCHC('"'); 
        if  (HASEXCEPTION())
        {
            goto ruleSTRINGEx;
        }


        // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:203:12: (~ ( '\"' | '\\n' | '\\r' ) )*

        for (;;)
        {
            int alt3=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA3_0 = LA(1);
                if ( (((LA3_0 >= 0x0000) && (LA3_0 <= '\t')) || ((LA3_0 >= 0x000B) && (LA3_0 <= '\f')) || ((LA3_0 >= 0x000E) && (LA3_0 <= '!')) || ((LA3_0 >= '#') && (LA3_0 <= 0xFFFF))) ) 
                {
                    alt3=1;
                }

            }
            switch (alt3) 
            {
        	case 1:
        	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:203:12: ~ ( '\"' | '\\n' | '\\r' )
        	    {
        	        if ( ((LA(1) >= 0x0000) && (LA(1) <= '\t')) || ((LA(1) >= 0x000B) && (LA(1) <= '\f')) || ((LA(1) >= 0x000E) && (LA(1) <= '!')) || ((LA(1) >= '#') && (LA(1) <= 0xFFFF)) )
        	        {
        	            CONSUME();

        	        }
        	        else 
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();    goto ruleSTRINGEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop3;	/* break out of the loop */
        	    break;
            }
        }
        loop3: ; /* Jump out to here if this rule does not match */

        MATCHC('"'); 
        if  (HASEXCEPTION())
        {
            goto ruleSTRINGEx;
        }

        {
            SETTEXT(LEXER->getText(LEXER)->subString(LEXER->getText(LEXER),1,LEXER->getText(LEXER)->len-1));
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleSTRINGEx; /* Prevent compiler warnings */
    ruleSTRINGEx: ;

}
// $ANTLR end STRING

//   Comes from: 207:2: ( ( '0' 'x' ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' )* | ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' )* 'h' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start HEX
 *
 * Looks to match the characters the constitute the token HEX
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mHEX(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = HEX;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:207:2: ( ( '0' 'x' ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' )* | ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' )* 'h' ) )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:208:2: ( '0' 'x' ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' )* | ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' )* 'h' )
    {

        // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:208:2: ( '0' 'x' ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' )* | ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' )* 'h' )
        {
            int alt6=2;
            switch ( LA(1) ) 
            {
            case '0':
            	{
            		switch ( LA(2) ) 
            		{
            		case 'x':
            			{
            				alt6=1;
            			}
            		    break;
            		case '0':
            		case '1':
            		case '2':
            		case '3':
            		case '4':
            		case '5':
            		case '6':
            		case '7':
            		case '8':
            		case '9':
            		case 'A':
            		case 'B':
            		case 'C':
            		case 'D':
            		case 'E':
            		case 'F':
            		case 'a':
            		case 'b':
            		case 'c':
            		case 'd':
            		case 'e':
            		case 'f':
            		case 'h':
            			{
            				alt6=2;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 6;
            		    EXCEPTION->state        = 1;


            		    goto ruleHEXEx;
            		}

            	}
                break;
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            case 'A':
            case 'B':
            case 'C':
            case 'D':
            case 'E':
            case 'F':
            case 'a':
            case 'b':
            case 'c':
            case 'd':
            case 'e':
            case 'f':
            case 'h':
            	{
            		alt6=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 6;
                EXCEPTION->state        = 0;


                goto ruleHEXEx;
            }

            switch (alt6) 
            {
        	case 1:
        	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:208:4: '0' 'x' ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' )*
        	    {
        	        MATCHC('0'); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleHEXEx;
        	        }

        	        MATCHC('x'); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleHEXEx;
        	        }


        	        // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:208:12: ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' )*

        	        for (;;)
        	        {
        	            int alt4=2;
        	            switch ( LA(1) ) 
        	            {
        	            case '0':
        	            case '1':
        	            case '2':
        	            case '3':
        	            case '4':
        	            case '5':
        	            case '6':
        	            case '7':
        	            case '8':
        	            case '9':
        	            case 'A':
        	            case 'B':
        	            case 'C':
        	            case 'D':
        	            case 'E':
        	            case 'F':
        	            case 'a':
        	            case 'b':
        	            case 'c':
        	            case 'd':
        	            case 'e':
        	            case 'f':
        	            	{
        	            		alt4=1;
        	            	}
        	                break;

        	            }

        	            switch (alt4) 
        	            {
        	        	case 1:
        	        	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:
        	        	    {
        	        	        if ( ((LA(1) >= '0') && (LA(1) <= '9')) || ((LA(1) >= 'A') && (LA(1) <= 'F')) || ((LA(1) >= 'a') && (LA(1) <= 'f')) )
        	        	        {
        	        	            CONSUME();

        	        	        }
        	        	        else 
        	        	        {
        	        	            CONSTRUCTEX();
        	        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	        	            LRECOVER();    goto ruleHEXEx;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop4;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop4: ; /* Jump out to here if this rule does not match */


        	    }
        	    break;
        	case 2:
        	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:209:5: ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' )* 'h'
        	    {

        	        // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:209:5: ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' )*

        	        for (;;)
        	        {
        	            int alt5=2;
        	            switch ( LA(1) ) 
        	            {
        	            case '0':
        	            case '1':
        	            case '2':
        	            case '3':
        	            case '4':
        	            case '5':
        	            case '6':
        	            case '7':
        	            case '8':
        	            case '9':
        	            case 'A':
        	            case 'B':
        	            case 'C':
        	            case 'D':
        	            case 'E':
        	            case 'F':
        	            case 'a':
        	            case 'b':
        	            case 'c':
        	            case 'd':
        	            case 'e':
        	            case 'f':
        	            	{
        	            		alt5=1;
        	            	}
        	                break;

        	            }

        	            switch (alt5) 
        	            {
        	        	case 1:
        	        	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:
        	        	    {
        	        	        if ( ((LA(1) >= '0') && (LA(1) <= '9')) || ((LA(1) >= 'A') && (LA(1) <= 'F')) || ((LA(1) >= 'a') && (LA(1) <= 'f')) )
        	        	        {
        	        	            CONSUME();

        	        	        }
        	        	        else 
        	        	        {
        	        	            CONSTRUCTEX();
        	        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	        	            LRECOVER();    goto ruleHEXEx;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop5;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop5: ; /* Jump out to here if this rule does not match */

        	        MATCHC('h'); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleHEXEx;
        	        }

        	        {
        	            SETTEXT(LEXER->getText(LEXER)->subString(LEXER->getText(LEXER),0,LEXER->getText(LEXER)->len-1));
        	        }

        	    }
        	    break;

            }
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleHEXEx; /* Prevent compiler warnings */
    ruleHEXEx: ;

}
// $ANTLR end HEX

//   Comes from: 214:2: ( ( '0' .. '9' )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start INT
 *
 * Looks to match the characters the constitute the token INT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mINT(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = INT;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:214:2: ( ( '0' .. '9' )+ )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:214:4: ( '0' .. '9' )+
    {
        // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:214:4: ( '0' .. '9' )+
        {
            int cnt7=0;

            for (;;)
            {
                int alt7=2;
        	switch ( LA(1) ) 
        	{
        	case '0':
        	case '1':
        	case '2':
        	case '3':
        	case '4':
        	case '5':
        	case '6':
        	case '7':
        	case '8':
        	case '9':
        		{
        			alt7=1;
        		}
        	    break;

        	}

        	switch (alt7) 
        	{
        	    case 1:
        	        // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:214:5: '0' .. '9'
        	        {
        	            MATCHRANGE('0', '9'); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleINTEx;
        	            }


        	        }
        	        break;

        	    default:
        	    
        		if ( cnt7 >= 1 )
        		{
        		    goto loop7;
        		}
        		/* mismatchedSetEx()
        		 */
        		CONSTRUCTEX();
        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        		goto ruleINTEx;
        	}
        	cnt7++;
            }
            loop7: ;	/* Jump to here if this rule does not match */
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleINTEx; /* Prevent compiler warnings */
    ruleINTEx: ;

}
// $ANTLR end INT

//   Comes from: 218:2: ( ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '?' | '$' | '@' ) ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '?' | '0' .. '9' | '@' | '$' )* )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SYMBOL
 *
 * Looks to match the characters the constitute the token SYMBOL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSYMBOL(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SYMBOL;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:218:2: ( ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '?' | '$' | '@' ) ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '?' | '0' .. '9' | '@' | '$' )* )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:218:4: ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '?' | '$' | '@' ) ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '?' | '0' .. '9' | '@' | '$' )*
    {
        if ( LA(1) == '$' || ((LA(1) >= '?') && (LA(1) <= 'Z')) || LA(1) == '_' || ((LA(1) >= 'a') && (LA(1) <= 'z')) )
        {
            CONSUME();

        }
        else 
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleSYMBOLEx;
        }


        // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:218:40: ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '?' | '0' .. '9' | '@' | '$' )*

        for (;;)
        {
            int alt8=2;
            switch ( LA(1) ) 
            {
            case '$':
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            case '?':
            case '@':
            case 'A':
            case 'B':
            case 'C':
            case 'D':
            case 'E':
            case 'F':
            case 'G':
            case 'H':
            case 'I':
            case 'J':
            case 'K':
            case 'L':
            case 'M':
            case 'N':
            case 'O':
            case 'P':
            case 'Q':
            case 'R':
            case 'S':
            case 'T':
            case 'U':
            case 'V':
            case 'W':
            case 'X':
            case 'Y':
            case 'Z':
            case '_':
            case 'a':
            case 'b':
            case 'c':
            case 'd':
            case 'e':
            case 'f':
            case 'g':
            case 'h':
            case 'i':
            case 'j':
            case 'k':
            case 'l':
            case 'm':
            case 'n':
            case 'o':
            case 'p':
            case 'q':
            case 'r':
            case 's':
            case 't':
            case 'u':
            case 'v':
            case 'w':
            case 'x':
            case 'y':
            case 'z':
            	{
            		alt8=1;
            	}
                break;

            }

            switch (alt8) 
            {
        	case 1:
        	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:
        	    {
        	        if ( LA(1) == '$' || ((LA(1) >= '0') && (LA(1) <= '9')) || ((LA(1) >= '?') && (LA(1) <= 'Z')) || LA(1) == '_' || ((LA(1) >= 'a') && (LA(1) <= 'z')) )
        	        {
        	            CONSUME();

        	        }
        	        else 
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();    goto ruleSYMBOLEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop8;	/* break out of the loop */
        	    break;
            }
        }
        loop8: ; /* Jump out to here if this rule does not match */


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleSYMBOLEx; /* Prevent compiler warnings */
    ruleSYMBOLEx: ;

}
// $ANTLR end SYMBOL

//   Comes from: 223:2: ( ' ' | '\\t' | '\\r' | '\\n' | '\\f' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start WSTOKEN
 *
 * Looks to match the characters the constitute the token WSTOKEN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mWSTOKEN(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:223:2: ( ' ' | '\\t' | '\\r' | '\\n' | '\\f' )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:
    {
        if ( ((LA(1) >= '\t') && (LA(1) <= '\n')) || ((LA(1) >= '\f') && (LA(1) <= '\r')) || LA(1) == ' ' )
        {
            CONSUME();

        }
        else 
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleWSTOKENEx;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleWSTOKENEx; /* Prevent compiler warnings */
    ruleWSTOKENEx: ;

}
// $ANTLR end WSTOKEN

//   Comes from: 227:2: ( WSTOKEN )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start WHITESPACE
 *
 * Looks to match the characters the constitute the token WHITESPACE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mWHITESPACE(pEEDGrammarLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = WHITESPACE;
       
    
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:227:2: ( WSTOKEN )
    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:227:6: WSTOKEN
    {
        /* 227:6: WSTOKEN */
        mWSTOKEN(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleWHITESPACEEx;
        }

        {
            LEXSTATE->channel=HIDDEN;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleWHITESPACEEx; /* Prevent compiler warnings */
    ruleWHITESPACEEx: ;

}
// $ANTLR end WHITESPACE

/** This is the entry point in to the lexer from an object that
 *  wants to generate the next token, such as a pCOMMON_TOKEN_STREAM
 */
static void 
mTokens(pEEDGrammarLexer ctx)
{
    {
        //  F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:8: ( APPLOADER | CODE | CONFORMING | DESCRIPTION | DEV386 | DISCARDABLE | DYNAMIC | EXECUTE_ONLY | EXECUTEONLY | EXECUTEREAD | EXETYPE | FIXED | FUNCTIONS | IMPORTS | IMPURE | INCLUDE | INITINSTANCE | IOPL | LOADONCALL | LONGNAMES | MOVABLE | MOVEABLE | MULTIPLE | NEWFILES | NODATA | NOIOPL | NONCONFORMING | NONDISCARDABLE | NONE | NONSHARED | NOTWINDOWCOMPAT | OBJECTS | OLD | PRELOAD | PROTMODE | PURE | READONLY | READWRITE | REALMODE | RESIDENT | RESIDENTNAME | SINGLE | WINDOWAPI | WINDOWCOMPAT | WINDOWS | T__56 | T__57 | T__58 | T__59 | T__60 | T__61 | T__62 | T__63 | T__64 | T__65 | T__66 | T__67 | T__68 | T__69 | T__70 | T__71 | T__72 | T__73 | T__74 | T__75 | T__76 | T__77 | T__78 | T__79 | T__80 | COMMENT | STRING | HEX | INT | SYMBOL | WHITESPACE )
        
        ANTLR3_UINT32 alt9;

        alt9=76;

        alt9 = cdfa9.predict(ctx, RECOGNIZER, ISTREAM, &cdfa9);
        if  (HASEXCEPTION())
        {
            goto ruleTokensEx;
        }

        switch (alt9) 
        {
    	case 1:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:10: APPLOADER
    	    {
    	        /* 1:10: APPLOADER */
    	        mAPPLOADER(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 2:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:20: CODE
    	    {
    	        /* 1:20: CODE */
    	        mCODE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 3:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:25: CONFORMING
    	    {
    	        /* 1:25: CONFORMING */
    	        mCONFORMING(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 4:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:36: DESCRIPTION
    	    {
    	        /* 1:36: DESCRIPTION */
    	        mDESCRIPTION(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 5:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:48: DEV386
    	    {
    	        /* 1:48: DEV386 */
    	        mDEV386(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 6:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:55: DISCARDABLE
    	    {
    	        /* 1:55: DISCARDABLE */
    	        mDISCARDABLE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 7:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:67: DYNAMIC
    	    {
    	        /* 1:67: DYNAMIC */
    	        mDYNAMIC(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 8:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:75: EXECUTE_ONLY
    	    {
    	        /* 1:75: EXECUTE_ONLY */
    	        mEXECUTE_ONLY(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 9:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:88: EXECUTEONLY
    	    {
    	        /* 1:88: EXECUTEONLY */
    	        mEXECUTEONLY(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 10:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:100: EXECUTEREAD
    	    {
    	        /* 1:100: EXECUTEREAD */
    	        mEXECUTEREAD(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 11:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:112: EXETYPE
    	    {
    	        /* 1:112: EXETYPE */
    	        mEXETYPE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 12:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:120: FIXED
    	    {
    	        /* 1:120: FIXED */
    	        mFIXED(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 13:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:126: FUNCTIONS
    	    {
    	        /* 1:126: FUNCTIONS */
    	        mFUNCTIONS(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 14:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:136: IMPORTS
    	    {
    	        /* 1:136: IMPORTS */
    	        mIMPORTS(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 15:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:144: IMPURE
    	    {
    	        /* 1:144: IMPURE */
    	        mIMPURE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 16:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:151: INCLUDE
    	    {
    	        /* 1:151: INCLUDE */
    	        mINCLUDE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 17:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:159: INITINSTANCE
    	    {
    	        /* 1:159: INITINSTANCE */
    	        mINITINSTANCE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 18:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:172: IOPL
    	    {
    	        /* 1:172: IOPL */
    	        mIOPL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 19:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:177: LOADONCALL
    	    {
    	        /* 1:177: LOADONCALL */
    	        mLOADONCALL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 20:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:188: LONGNAMES
    	    {
    	        /* 1:188: LONGNAMES */
    	        mLONGNAMES(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 21:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:198: MOVABLE
    	    {
    	        /* 1:198: MOVABLE */
    	        mMOVABLE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 22:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:206: MOVEABLE
    	    {
    	        /* 1:206: MOVEABLE */
    	        mMOVEABLE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 23:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:215: MULTIPLE
    	    {
    	        /* 1:215: MULTIPLE */
    	        mMULTIPLE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 24:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:224: NEWFILES
    	    {
    	        /* 1:224: NEWFILES */
    	        mNEWFILES(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 25:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:233: NODATA
    	    {
    	        /* 1:233: NODATA */
    	        mNODATA(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 26:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:240: NOIOPL
    	    {
    	        /* 1:240: NOIOPL */
    	        mNOIOPL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 27:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:247: NONCONFORMING
    	    {
    	        /* 1:247: NONCONFORMING */
    	        mNONCONFORMING(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 28:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:261: NONDISCARDABLE
    	    {
    	        /* 1:261: NONDISCARDABLE */
    	        mNONDISCARDABLE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 29:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:276: NONE
    	    {
    	        /* 1:276: NONE */
    	        mNONE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 30:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:281: NONSHARED
    	    {
    	        /* 1:281: NONSHARED */
    	        mNONSHARED(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 31:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:291: NOTWINDOWCOMPAT
    	    {
    	        /* 1:291: NOTWINDOWCOMPAT */
    	        mNOTWINDOWCOMPAT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 32:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:307: OBJECTS
    	    {
    	        /* 1:307: OBJECTS */
    	        mOBJECTS(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 33:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:315: OLD
    	    {
    	        /* 1:315: OLD */
    	        mOLD(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 34:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:319: PRELOAD
    	    {
    	        /* 1:319: PRELOAD */
    	        mPRELOAD(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 35:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:327: PROTMODE
    	    {
    	        /* 1:327: PROTMODE */
    	        mPROTMODE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 36:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:336: PURE
    	    {
    	        /* 1:336: PURE */
    	        mPURE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 37:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:341: READONLY
    	    {
    	        /* 1:341: READONLY */
    	        mREADONLY(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 38:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:350: READWRITE
    	    {
    	        /* 1:350: READWRITE */
    	        mREADWRITE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 39:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:360: REALMODE
    	    {
    	        /* 1:360: REALMODE */
    	        mREALMODE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 40:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:369: RESIDENT
    	    {
    	        /* 1:369: RESIDENT */
    	        mRESIDENT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 41:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:378: RESIDENTNAME
    	    {
    	        /* 1:378: RESIDENTNAME */
    	        mRESIDENTNAME(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 42:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:391: SINGLE
    	    {
    	        /* 1:391: SINGLE */
    	        mSINGLE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 43:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:398: WINDOWAPI
    	    {
    	        /* 1:398: WINDOWAPI */
    	        mWINDOWAPI(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 44:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:408: WINDOWCOMPAT
    	    {
    	        /* 1:408: WINDOWCOMPAT */
    	        mWINDOWCOMPAT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 45:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:421: WINDOWS
    	    {
    	        /* 1:421: WINDOWS */
    	        mWINDOWS(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 46:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:429: T__56
    	    {
    	        /* 1:429: T__56 */
    	        mT__56(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 47:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:435: T__57
    	    {
    	        /* 1:435: T__57 */
    	        mT__57(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 48:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:441: T__58
    	    {
    	        /* 1:441: T__58 */
    	        mT__58(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 49:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:447: T__59
    	    {
    	        /* 1:447: T__59 */
    	        mT__59(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 50:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:453: T__60
    	    {
    	        /* 1:453: T__60 */
    	        mT__60(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 51:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:459: T__61
    	    {
    	        /* 1:459: T__61 */
    	        mT__61(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 52:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:465: T__62
    	    {
    	        /* 1:465: T__62 */
    	        mT__62(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 53:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:471: T__63
    	    {
    	        /* 1:471: T__63 */
    	        mT__63(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 54:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:477: T__64
    	    {
    	        /* 1:477: T__64 */
    	        mT__64(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 55:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:483: T__65
    	    {
    	        /* 1:483: T__65 */
    	        mT__65(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 56:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:489: T__66
    	    {
    	        /* 1:489: T__66 */
    	        mT__66(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 57:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:495: T__67
    	    {
    	        /* 1:495: T__67 */
    	        mT__67(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 58:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:501: T__68
    	    {
    	        /* 1:501: T__68 */
    	        mT__68(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 59:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:507: T__69
    	    {
    	        /* 1:507: T__69 */
    	        mT__69(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 60:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:513: T__70
    	    {
    	        /* 1:513: T__70 */
    	        mT__70(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 61:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:519: T__71
    	    {
    	        /* 1:519: T__71 */
    	        mT__71(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 62:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:525: T__72
    	    {
    	        /* 1:525: T__72 */
    	        mT__72(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 63:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:531: T__73
    	    {
    	        /* 1:531: T__73 */
    	        mT__73(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 64:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:537: T__74
    	    {
    	        /* 1:537: T__74 */
    	        mT__74(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 65:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:543: T__75
    	    {
    	        /* 1:543: T__75 */
    	        mT__75(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 66:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:549: T__76
    	    {
    	        /* 1:549: T__76 */
    	        mT__76(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 67:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:555: T__77
    	    {
    	        /* 1:555: T__77 */
    	        mT__77(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 68:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:561: T__78
    	    {
    	        /* 1:561: T__78 */
    	        mT__78(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 69:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:567: T__79
    	    {
    	        /* 1:567: T__79 */
    	        mT__79(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 70:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:573: T__80
    	    {
    	        /* 1:573: T__80 */
    	        mT__80(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 71:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:579: COMMENT
    	    {
    	        /* 1:579: COMMENT */
    	        mCOMMENT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 72:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:587: STRING
    	    {
    	        /* 1:587: STRING */
    	        mSTRING(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 73:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:594: HEX
    	    {
    	        /* 1:594: HEX */
    	        mHEX(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 74:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:598: INT
    	    {
    	        /* 1:598: INT */
    	        mINT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 75:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:602: SYMBOL
    	    {
    	        /* 1:602: SYMBOL */
    	        mSYMBOL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 76:
    	    // F:\\Game Sources\\Elder Scrolls IV Oblivion\\My Mods\\COEF\\ExportInjector\\EEDGrammar.g:1:609: WHITESPACE
    	    {
    	        /* 1:609: WHITESPACE */
    	        mWHITESPACE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;

        }
    }

    
    goto ruleTokensEx; /* Prevent compiler warnings */
ruleTokensEx: ;
}

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */
/* End of Lexer code
 * ================================================
 * ================================================
 */ 


/* End of code
 * =============================================================================
 */
