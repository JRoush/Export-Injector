; *********************************************************************************************************
; Extended Export Definition Format (*.eed)
;{
;   This file may be used with the ExportInjector library to dynamically generate export directories for 
;   the target module(s) at run time, and to generate Module Definition (.def) files for use with LIB.exe.  
;   (LIB.exe can create import libraries (.lib) necessary for compile-time linking from .def files).
;
;   The syntax of this file is based on the Module Definition file format - see MS documentation for specs.
;   This means that very simple .eed files can be read directly by LIB.exe.  Most .eed files, though,  can 
;   only be read by the ExportInjector library.
;
;   Use the NAME statement to specify the filename of the target module(s). Multiple target modules may be
;   given, seperated by commas.  Any other statements that follow will act on these targets.  Filenames may 
;   be in double quotes, to allow for spaces and other problematic characters.
;
;       NAME moduleName1 [, moduleName2, ...]
;   
;   Use the BASE statement to specify the requested base address for the target module(s).  This is the base
;   that the module was compiled at, and will be loaded at if it is not already taken by another module.
;   If a base address is not specified for a module, the default value of zero is used.
;
;       BASE = requestedBase1 [, requestedBase2, ...]
;
;   Use the EXPORTS statement to specify an exported symbol or symbols.  ExportInjector will add these to the
;   export table of the target module and to any def files produced.  A single EXPORTS statement may contain mutliple
;   symbol specifications, separated by whitespace.
;   For each target module, an exported symbol must provide a Source - either a numerical memory address or the name of 
;   another symbol to alias for.  The sources should be separated by commas, and be in the same order as the 
;   target modules in the NAME statement. 
;   If the source is a memory address, it may be relative to the module base (prefix #) or absolute (no prefix #).  
;   Relative addresses are what is actually required, so all absolute addresses are made relative by subtracting 
;   the requestedBase for the target module.  
;   If the source is a symbol name, it may optionally be from another module.  Both symbol and module must already
;   be loaded by the parent process, or the symbol resolution will fail.
;   Symbols may contain upper & lower case letters, digits, '_', '$', '@', and '?', but may not begin with a digit.  
;   This includes all valid C and C++ identifiers and all 'decorated' symbols generated by Microsoft compilers.   
;
;       EXPORTS symbol = sourceSymbol1[:sourceModule1] [, sourceSymbol2[:sourceModule2], ...]
;       EXPORTS symbol = [#]sourceAddress1 [, [#]sourceAddress2, ...]
;
;   Comments may appear anywhere in the file, marked with a single semicolon and terminated by a line break.
;}
; **********************************************************************************************************

NAME Oblivion.exe, TESConstructionSet.exe   ; target Oblivion.exe and TESConstructionSet.exe

BASE = 0x400000, 0x400000                   ; both module images request the base 0x400000 in memory

EXPORTS

; void __cdecl PrintToConsole(const char * format, ...);
; use absolute address 0x579B9B for Oblivion.exe
; ExportInjector will subtract off 0x400000 to get relative address 0x179B9B
; Function does not exist is CS, indicate with a non-existant source symbol
PrintToConsole = 0x00579B9B, NOT_IN_CS 

; TESForm* __cdecl LookupByFormID(unsigned long formID);
; use relative addresses 0x06B250 & 0x095EF0 for game & CS
LookupByFormID = #0x06B250, #0x095EF0

; define an alias for LookupByFormID in both modules
LookupAlias = LookupByFormID, LookupByFormID ; dickles